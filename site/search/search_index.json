{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to eConEXG's documentation.","text":"<p>For more infomation, please visit our Github repository.</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li> <p>Online:</p> <p><code>pip install econexg</code></p> </li> <li> <p>Offline:</p> <p><code>pip install econexg-x.x.x-py3-none-any.whl</code></p> </li> </ul>"},{"location":"#network-connection-is-required-to-download-dependencies","title":"* Network connection is required to download dependencies.","text":""},{"location":"#optional-dependencies-can-be-installed-via-pip-install-econexgoption1option2","title":"Optional dependencies can be installed via <code>pip install econexg[option1,option2,...]</code>","text":"<ul> <li>Available options:<ul> <li>bdf: save to BDF file functionality support.</li> <li>lsl: LSL stream functionality support.</li> <li>wifi: iRecorder W32 wifi model support, msvc build tools required.</li> </ul> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Example code can be found in examples.</p>"},{"location":"#platform-support","title":"Platform Support","text":"Hardware Windows macOS Linux iRecorder USB \u2713 \u2713 \u2713 iRecorder W8 | W16 \u2713 \ud800\udd02 \ud800\udd02 iRecorder W32 \u2713 \u2713 \u2713 iFocus \u2713 \u2713 \u2713 TriggerBox \u2713 \u2713 \u2713"},{"location":"#more","title":"More","text":"<ul> <li>Discussion Forum, to discuss the project   on GitHub</li> <li>Issue Tracker, if you run into bugs or have suggestions</li> <li>License: MIT</li> </ul>"},{"location":"about/","title":"About","text":"<p>StatusCode        : 200 StatusDescription : OK Content           : # Orta comitata poenas quia crudelis animo foedataque</p> <pre><code>                ## Daedale nunc armis fuerant lecturum\n\n                Lorem markdownum rursus, via regnat conparentis mittor ignorans te audacia\n                lapillo et Paris iuvenci, indi...\n</code></pre> <p>RawContent        : HTTP/1.1 200 OK                     Transfer-Encoding: chunked                     Connection: keep-alive                     access-control-allow-origin: *                     Content-Type: text/plain; charset=utf-8                     Date: Mon, 27 May 2024 08:21:20 GMT                     Server: nginx/1.14.2... Forms             : {} Headers           : {[Transfer-Encoding, chunked], [Connection, keep-alive], [access-control-allow-origin, *], [Content-Type, text/plain; charset=utf-8]...} Images            : {} InputFields       : {} Links             : {} ParsedHtml        : mshtml.HTMLDocumentClass RawContentLength  : 3063</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you can find all the released changes to eConEXG.</p>"},{"location":"changelog/#0111","title":"0.1.11","text":"<p>Released on 2024-07-12.</p> <ul> <li>Update documentation homepage.</li> </ul>"},{"location":"changelog/#0110","title":"0.1.10","text":"<p>Released on 2024-07-08.</p> <ul> <li>Add support for iRecorder 16-channel wired mode.</li> <li>change default timeout of get_data() to 0.02s.</li> <li>Add lsl support for iFocus. </li> </ul>"},{"location":"changelog/#0109","title":"0.1.09","text":"<p>Released on 2024-06-28.</p> <ul> <li>Add support for iRecorder 8-channel wired mode.</li> </ul>"},{"location":"iFocus/","title":"iFocus","text":""},{"location":"iFocus/#eConEXG.iFocus.iFocus","title":"<code>iFocus</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>class iFocus(Thread):\n    class Dev(Enum):\n        SIGNAL = 10\n        SIGNAL_START = 11\n        IDLE = 30\n        IDLE_START = 31\n        TERMINATE = 40\n        TERMINATE_START = 41\n\n    _dev_args = {\n        \"type\": \"iFocus\",\n        \"fs_eeg\": 250,\n        \"fs_imu\": 50,\n        \"channel_eeg\": {0: \"CH0\"},\n        \"channel_imu\": {0: \"X\", 1: \"Y\", 2: \"Z\"},\n        \"AdapterInfo\": \"Serial Port\",\n    }\n\n    def __init__(self, port: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Args:\n            port: if not given, connect to the first available device\n        \"\"\"\n        super().__init__(daemon=True)\n        if port is None:\n            port = iFocus.find_devs()[0]\n        self.__save_data = Queue()\n        self.__parser = Parser()\n        self.dev = sock(port)\n        self.__socket_flag = 1\n        try:\n            self.dev.connect_socket()\n        except Exception as e:\n            try:\n                self.dev.close_socket()\n            finally:\n                raise e\n        self.__status = iFocus.Dev.IDLE_START\n        self.__socket_flag = 0\n        self.__lsl_imu_flag = False\n        self.__lsl_eeg_flag = False\n        self._dev_args[\"name\"] = port\n        self.start()\n\n    @staticmethod\n    def find_devs() -&gt; list:\n        \"\"\"\n        Find available iFocus devices.\n\n        Returns:\n            available device ports.\n\n        Raises:\n            Exception: if no iFocus device found.\n        \"\"\"\n        return sock._find_devs()\n\n    def get_data(self, timeout: Optional[float] = 0.02) -&gt; list[Optional[list]]:\n        \"\"\"\n        Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.\n\n        Args:\n            timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n        Returns:\n            A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below:\n                [[`eeg_0`], [`eeg_1`], [`eeg_2`], [`eeg_3`], [`eeg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                    in which number `0~4` after `_` indicates the time order of channel data.\n\n        Raises:\n            Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n        Data Unit:\n            - eeg: \u00b5V\n            - imu: degree(\u00b0)\n        \"\"\"\n        if self.__socket_flag:\n            self.__raise_sock_error()\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def start_acquisition_data(self) -&gt; None:\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n        \"\"\"\n        if self.__status == iFocus.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iFocus.Dev.SIGNAL:\n            return\n        self.__status = iFocus.Dev.SIGNAL_START\n        while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iFocus.Dev.SIGNAL:\n            self.__raise_sock_error()\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n        \"\"\"\n        if self.__status == iFocus.Dev.TERMINATE:\n            self.__raise_sock_error()\n        self.__status = iFocus.Dev.IDLE_START\n        while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iFocus.Dev.IDLE:\n            self.__raise_sock_error()\n\n    def open_lsl_eeg(self):\n        \"\"\"\n        Open LSL EEG stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_eeg\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_eeg = lslSender(\n            self._dev_args[\"channel_eeg\"],\n            f\"{self._dev_args['type']}EEG{self._dev_args['name'][-2:]}\",\n            \"EEG\",\n            self._dev_args[\"fs_eeg\"],\n            with_trigger=False,\n        )\n        self.__lsl_eeg_flag = True\n\n    def close_lsl_eeg(self):\n        \"\"\"\n        Close LSL EEG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_eeg_flag = False\n        if hasattr(self, \"_lsl_eeg\"):\n            del self._lsl_eeg\n\n    def open_lsl_imu(self):\n        \"\"\"\n        Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_imu\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_imu = lslSender(\n            self._dev_args[\"channel_imu\"],\n            f\"{self._dev_args['type']}IMU{self._dev_args['name'][-2:]}\",\n            \"IMU\",\n            self._dev_args[\"fs_imu\"],\n            unit=\"degree\",\n            with_trigger=False,\n        )\n        self.__lsl_imu_flag = True\n\n    def close_lsl_imu(self):\n        \"\"\"\n        Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_imu_flag = False\n        if hasattr(self, \"_lsl_imu\"):\n            del self._lsl_imu\n\n    def close_dev(self):\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != iFocus.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iFocus.Dev.TERMINATE_START\n            while self.__status != iFocus.Dev.TERMINATE:\n                time.sleep(0.1)\n        if self.is_alive():\n            self.join()\n\n    def __recv_data(self):\n        try:\n            self.dev.start_data()\n            self.__status = iFocus.Dev.SIGNAL\n        except Exception:\n            print(\"SIGNAL START FAILED!\")\n            self.__socket_flag = 4\n            self.__status = iFocus.Dev.TERMINATE_START\n\n        print(\"SIGNAL START\")\n        while self.__status in [iFocus.Dev.SIGNAL]:\n            try:\n                data = self.dev.recv_socket()\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    if self.__lsl_eeg_flag:\n                        self._lsl_eeg.push_chunk(\n                            [frame for frames in ret for frame in frames[:-1]]\n                        )\n                    if self.__lsl_imu_flag:\n                        self._lsl_imu.push_chunk([frame[-1] for frame in ret])\n                    self.__save_data.put(ret)\n            except Exception:\n                traceback.print_exc()\n                self.__socket_flag = 3\n                self.__status = iFocus.Dev.TERMINATE_START\n\n        # clear buffer\n        self.close_lsl_eeg()\n        self.close_lsl_imu()\n        # self.dev.stop_recv()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != iFocus.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == iFocus.Dev.IDLE_START:\n                    self.__socket_flag = 5\n                self.__status = iFocus.Dev.TERMINATE_START\n\n    def run(self):\n        print(\"iFocus connected\")\n        while self.__status != iFocus.Dev.TERMINATE_START:\n            if self.__status == iFocus.Dev.SIGNAL_START:\n                self.__recv_data()\n            elif self.__status == iFocus.Dev.IDLE_START:\n                self.__status = iFocus.Dev.IDLE\n                while self.__status == iFocus.Dev.IDLE:\n                    time.sleep(0.1)\n            else:\n                print(f\"Unknown status: {self.__status}\")\n                break\n        try:\n            self.dev.close_socket()\n        except Exception:\n            print(\"socket close failed\")\n        finally:\n            self.__status = iFocus.Dev.TERMINATE\n            print(\"iFocus disconnected\")\n\n    def __raise_sock_error(self):\n        if self.__socket_flag == 0:\n            return\n        if self.is_alive():\n            self.close_dev()\n        if self.__socket_flag == 1:\n            raise Exception(\"Device not connected, please connect first.\")\n        elif self.__socket_flag == 2:\n            raise Exception(\"Device connection failed.\")\n        elif self.__socket_flag == 3:\n            raise Exception(\"Data transmission timeout.\")\n        elif self.__socket_flag == 4:\n            raise Exception(\"Data/Impedance mode initialization failed.\")\n        else:\n            raise Exception(f\"Unknown error: {self.__socket_flag}\")\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>if not given, connect to the first available device</p> <code>None</code> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def __init__(self, port: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Args:\n        port: if not given, connect to the first available device\n    \"\"\"\n    super().__init__(daemon=True)\n    if port is None:\n        port = iFocus.find_devs()[0]\n    self.__save_data = Queue()\n    self.__parser = Parser()\n    self.dev = sock(port)\n    self.__socket_flag = 1\n    try:\n        self.dev.connect_socket()\n    except Exception as e:\n        try:\n            self.dev.close_socket()\n        finally:\n            raise e\n    self.__status = iFocus.Dev.IDLE_START\n    self.__socket_flag = 0\n    self.__lsl_imu_flag = False\n    self.__lsl_eeg_flag = False\n    self._dev_args[\"name\"] = port\n    self.start()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_dev(self):\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != iFocus.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iFocus.Dev.TERMINATE_START\n        while self.__status != iFocus.Dev.TERMINATE:\n            time.sleep(0.1)\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_lsl_eeg","title":"<code>close_lsl_eeg()</code>","text":"<p>Close LSL EEG stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_lsl_eeg(self):\n    \"\"\"\n    Close LSL EEG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_eeg_flag = False\n    if hasattr(self, \"_lsl_eeg\"):\n        del self._lsl_eeg\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_lsl_imu","title":"<code>close_lsl_imu()</code>","text":"<p>Close LSL IMU stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_lsl_imu(self):\n    \"\"\"\n    Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_imu_flag = False\n    if hasattr(self, \"_lsl_imu\"):\n        del self._lsl_imu\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.find_devs","title":"<code>find_devs()</code>  <code>staticmethod</code>","text":"<p>Find available iFocus devices.</p> <p>Returns:</p> Type Description <code>list</code> <p>available device ports.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if no iFocus device found.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>@staticmethod\ndef find_devs() -&gt; list:\n    \"\"\"\n    Find available iFocus devices.\n\n    Returns:\n        available device ports.\n\n    Raises:\n        Exception: if no iFocus device found.\n    \"\"\"\n    return sock._find_devs()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.get_data","title":"<code>get_data(timeout=0.02)</code>","text":"<p>Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Non-negative value, blocks at most 'timeout' seconds and return, if set to <code>None</code>, blocks until new data available.</p> <code>0.02</code> <p>Returns:</p> Type Description <code>list[Optional[list]]</code> <p>A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below: [[<code>eeg_0</code>], [<code>eeg_1</code>], [<code>eeg_2</code>], [<code>eeg_3</code>], [<code>eeg_4</code>], [<code>imu_x</code>, <code>imu_y</code>, <code>imu_z</code>]],     in which number <code>0~4</code> after <code>_</code> indicates the time order of channel data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected, connection failed, data transmission timeout/init failed, or unknown error.</p> Data Unit <ul> <li>eeg: \u00b5V</li> <li>imu: degree(\u00b0)</li> </ul> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def get_data(self, timeout: Optional[float] = 0.02) -&gt; list[Optional[list]]:\n    \"\"\"\n    Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.\n\n    Args:\n        timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n    Returns:\n        A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below:\n            [[`eeg_0`], [`eeg_1`], [`eeg_2`], [`eeg_3`], [`eeg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                in which number `0~4` after `_` indicates the time order of channel data.\n\n    Raises:\n        Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n    Data Unit:\n        - eeg: \u00b5V\n        - imu: degree(\u00b0)\n    \"\"\"\n    if self.__socket_flag:\n        self.__raise_sock_error()\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.open_lsl_eeg","title":"<code>open_lsl_eeg()</code>","text":"<p>Open LSL EEG stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def open_lsl_eeg(self):\n    \"\"\"\n    Open LSL EEG stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_eeg\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_eeg = lslSender(\n        self._dev_args[\"channel_eeg\"],\n        f\"{self._dev_args['type']}EEG{self._dev_args['name'][-2:]}\",\n        \"EEG\",\n        self._dev_args[\"fs_eeg\"],\n        with_trigger=False,\n    )\n    self.__lsl_eeg_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.open_lsl_imu","title":"<code>open_lsl_imu()</code>","text":"<p>Open LSL IMU stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def open_lsl_imu(self):\n    \"\"\"\n    Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_imu\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_imu = lslSender(\n        self._dev_args[\"channel_imu\"],\n        f\"{self._dev_args['type']}IMU{self._dev_args['name'][-2:]}\",\n        \"IMU\",\n        self._dev_args[\"fs_imu\"],\n        unit=\"degree\",\n        with_trigger=False,\n    )\n    self.__lsl_imu_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.start_acquisition_data","title":"<code>start_acquisition_data()</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def start_acquisition_data(self) -&gt; None:\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n    \"\"\"\n    if self.__status == iFocus.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iFocus.Dev.SIGNAL:\n        return\n    self.__status = iFocus.Dev.SIGNAL_START\n    while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iFocus.Dev.SIGNAL:\n        self.__raise_sock_error()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n    \"\"\"\n    if self.__status == iFocus.Dev.TERMINATE:\n        self.__raise_sock_error()\n    self.__status = iFocus.Dev.IDLE_START\n    while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iFocus.Dev.IDLE:\n        self.__raise_sock_error()\n</code></pre>"},{"location":"iRecorder/","title":"iRecorder","text":""},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder","title":"<code>iRecorder</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>class iRecorder(Thread):\n    class Dev(Enum):\n        SIGNAL = 10  # signal transmision mode\n        SIGNAL_START = 11\n        IMPEDANCE = 20  # impedance transmision mode\n        IMPEDANCE_START = 21\n        IDLE = 30  # idle mode\n        IDLE_START = 31\n        TERMINATE = 40  # Init state\n        TERMINATE_START = 41\n\n    def __init__(self, dev_type: Literal[\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"]):\n        \"\"\"\n        Args:\n            dev_type: iRecorder device type.\n\n        Raises:\n            Exception: if device type not supported.\n            Exception: if adapter not available.\n        \"\"\"\n        if dev_type not in {\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"}:\n            raise ValueError(\"Unsupported device type.\")\n        super().__init__(daemon=True, name=f\"iRecorder {dev_type}\")\n        self.__info_q = Queue(128)\n        self.__socket_flag = 1\n        self.__save_data = Queue()\n        self.__status = iRecorder.Dev.TERMINATE\n        self.__lsl_flag = False\n        self.__bdf_flag = False\n        self.__dev_args = {\"type\": dev_type}\n        self.__dev_args.update({\"channel\": self.__get_chs()})\n\n        self.__parser = Parser(self.__dev_args[\"channel\"])\n        self.__interface = get_interface(dev_type)(self.__info_q)\n        self.__dev_sock = get_sock(dev_type)\n        self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n        self.set_frequency()\n        self.update_channels()\n\n    def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n        \"\"\"\n        Search for available devices, can only be called once per instance.\n\n        Args:\n            duration: Search interval in seconds, blocks for about `duration` seconds and return found devices,\n                if set to `None`, return `None` immediately, devices can later be acquired by calling `get_devs()` in a loop.\n\n        Returns:\n            Available devices.\n\n        Raises:\n            Exception: If search thread already running or iRecorder already connected.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected.\")\n        if self.__interface.is_alive():\n            raise Exception(\"Search thread already running.\")\n        self.__interface.start()\n        if duration is None:\n            return\n        start = time.time()\n        while time.time() - start &lt; duration:\n            time.sleep(0.5)\n        self.__finish_search()\n        return self.get_devs()\n\n    def get_devs(self, verbose: bool = False) -&gt; list:\n        \"\"\"\n        Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n            each call will *only* return newly found devices.\n\n        Args:\n            verbose: if True, return all available devices information, otherwise only return names for connection,\n                if you don't know what this parameter does, just leave it at its default value.\n\n        Returns:\n            Newly found devices.\n\n        Raises:\n            Exception: adapter not found or not enabled etc.\n        \"\"\"\n        ret = []\n        time.sleep(0.1)\n        while not self.__info_q.empty():\n            info = self.__info_q.get()\n            if isinstance(info, list):\n                ret.append(info if verbose else info[-1])\n            elif isinstance(info, bool):\n                if verbose:\n                    ret.append(info)\n            elif isinstance(info, str):\n                raise Exception(info)\n        return ret\n\n    def get_dev_status(self) -&gt; str:\n        \"\"\"\n        Get current device status.\n\n        Returns:\n            \"SIGNAL\": data acquisition mode\n            \"IMPEDANCE\": impedance acquisition mode\n            \"IDLE\": idle mode\n            \"TERMINATE\": device not connected or connection closed.\n        \"\"\"\n        return self.__status.name\n\n    def get_dev_info(self) -&gt; dict:\n        \"\"\"\n        Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n        Returns:\n            A dictionary containing device information, which includes:\n                `type`: hardware type;\n                `channel`: hardware channel number;\n                `AdapterInfo`: adapter used for connection;\n                `fs`: sample frequency in Hz;\n                `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self.__dev_args)\n\n    def get_available_frequency(self) -&gt; list:\n        \"\"\"Get available sample frequency of device.\n\n        Returns:\n            Available sample frequencies in Hz.\n        \"\"\"\n        if \"USB\" in self.__dev_args[\"type\"]:\n            return [500, 1000, 2000]\n        return [500]\n\n    def set_frequency(self, fs: int = None):\n        \"\"\"Update device sample frequency, this method should be invoked before `connect_device`.\n\n        Args:\n            fs: sample frequency in Hz, if `fs` is set to `None` or not in `get_available_frequency()`,\n                it will fallback to the lowest available frequency.\n\n        Raises:\n            Exception: Device is already connected.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"Set frequency failed, device already connected.\")\n        default = self.get_available_frequency()[0]\n        if fs is None:\n            fs = default\n        if fs not in self.get_available_frequency():\n            print(f\"Invalid sample frequency, fallback to {default}Hz\")\n            fs = default\n        self.__dev_args.update({\"fs\": fs})\n        self.__parser._update_fs(fs)\n\n    def connect_device(self, addr: str) -&gt; None:\n        \"\"\"\n        Connect to device by address, block until connection is established or failed.\n\n        Args:\n            addr: device address.\n\n        Raises:\n            Exception: if device already connected or connection failed.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected\")\n        try:\n            ret = self.__interface.connect(addr)\n            self.__dev_args.update({\"name\": addr[-2:], \"sock\": ret})\n            self.__dev_args.update({\"_length\": self.__parser._threshold})\n            self.dev = self.__dev_sock(self.__dev_args)\n            self.__parser.batt_val = self.dev.send_heartbeat()\n            self.__socket_flag = 0\n            self.__info_q.put(True)\n            self.__status = iRecorder.Dev.IDLE_START\n            self.start()\n        except Exception as e:\n            self.__info_q.put(str(e))\n            self.__socket_flag = 2\n            self.__finish_search()\n            raise e\n\n    def update_channels(self, channels: Optional[dict] = None):\n        \"\"\"\n        update channel information, valid only when device is not acquiring data or impedance.\n\n        Args:\n            channels: channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"},\n                if `None` is given, reset to all available channels with default names.\n\n        Raises:\n            Exception: if data/impedance acquisition in progress.\n        \"\"\"\n        if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            raise Exception(\n                \"Device acquisition in progress, please `stop_acquisition` first.\"\n            )\n        if channels is None:\n            from .default_config import getChannels\n\n            channels = getChannels(self.__dev_args[\"channel\"])\n        self.__dev_args.update({\"ch_info\": channels})\n        ch_idx = [i for i in channels.keys()]\n        self.__parser.update_chs(ch_idx)\n\n    def start_acquisition_data(self):\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n\n        Raises:\n            Exception: if device not connected or data acquisition init failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iRecorder.Dev.SIGNAL:\n            return None\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.SIGNAL_START\n        while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.SIGNAL:\n            self.__raise_sock_error()\n        return None\n\n    def get_data(self, timeout: Optional[float] = 0.02) -&gt; list[Optional[list]]:\n        \"\"\"\n        Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n        Args:\n            timeout: Non-negative value, blocks at most `timeout` seconds and return, if set to `None`, blocks until new data is available.\n\n        Returns:\n            A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel,\n                eeg channels can be updatd by `update_channels()`.\n\n        Data Unit:\n            - eeg: microvolts (\u00b5V)\n            - triggerbox: int, from `0` to `255`\n\n        Raises:\n            Exception: if device not connected or in data acquisition mode.\n        \"\"\"\n        if self.__socket_flag:\n            self.__raise_sock_error()\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n        Raises:\n            Exception: if device not connected or acquisition stop failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        self.__status = iRecorder.Dev.IDLE_START\n        while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.IDLE:\n            self.__raise_sock_error()\n        return None\n\n    def start_acquisition_impedance(self) -&gt; None:\n        \"\"\"\n        Send impedance acquisition command to device, block until data acquisition started or failed.\n\n        Raises:\n            Exception: if device not connected or impedance acquisition init failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            return None\n        if self.__status == iRecorder.Dev.SIGNAL:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.IMPEDANCE_START\n        while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.IMPEDANCE:\n            self.__raise_sock_error()\n        return None\n\n    def get_impedance(self) -&gt; Optional[list]:\n        \"\"\"\n        Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.\n\n        Returns:\n            A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n        Data Unit:\n            - impedance: ohm (\u03a9)\n        \"\"\"\n        if self.__socket_flag:\n            if self.is_alive():\n                self.close_dev()\n            self.__raise_sock_error()\n        return self.__parser.impedance\n\n    def close_dev(self) -&gt; None:\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != iRecorder.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iRecorder.Dev.TERMINATE_START\n            while self.__status != iRecorder.Dev.TERMINATE:\n                time.sleep(0.01)\n        self.__finish_search()\n        if self.is_alive():\n            self.join()\n\n    def get_packet_drop_times(self) -&gt; int:\n        \"\"\"\n        Retrieve packet drop times.\n        This value accumulates during data transmission and will be reset to `0` after device status change.\n\n        Returns:\n            accumulated packet drop times.\n        \"\"\"\n        return self.__parser._drop_count\n\n    def get_battery_value(self) -&gt; int:\n        \"\"\"\n        Query battery level.\n\n        Returns:\n            battery level in percentage, range from `0` to `100`.\n        \"\"\"\n        return self.__parser.batt_val\n\n    def open_lsl_stream(self):\n        \"\"\"\n        Open LSL stream, can be invoked after `start_acquisition_data()`,\n            each frame is the same as described in `get_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_stream\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_stream = lslSender(\n            self.__dev_args[\"ch_info\"],\n            f\"iRe{self.__dev_args['type']}{self.__dev_args['name'][-2:]}\",\n            \"EEG\",\n            self.__dev_args[\"fs\"],\n            with_trigger=True,\n        )\n        self.__lsl_flag = True\n\n    def close_lsl_stream(self):\n        \"\"\"\n        Close LSL stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_flag = False\n        if hasattr(self, \"_lsl_stream\"):\n            del self._lsl_stream\n\n    def save_bdf_file(self, filename: str):\n        \"\"\"\n        Save data to BDF file, can be invoked after `start_acquisition_data()`.\n\n        Args:\n            filename: file name to save data, accept absolute or relative path.\n\n        Raises:\n            Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n            OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n            importError: if `pyedflib` is not installed.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started\")\n        if hasattr(self, \"_bdf_file\"):\n            raise Exception(\"BDF file already created.\")\n        from ..utils.bdfWrapper import bdfSaver\n\n        if filename[-4:].lower() != \".bdf\":\n            filename += \".bdf\"\n        self._bdf_file = bdfSaver(\n            filename,\n            self.__dev_args[\"ch_info\"],\n            self.__dev_args[\"fs\"],\n            f\"iRecorder {self.__dev_args['type']}\",\n        )\n        self.__bdf_flag = True\n\n    def close_bdf_file(self):\n        \"\"\"\n        Close and save BDF file manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__bdf_flag = False\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.close_bdf()\n            del self._bdf_file\n\n    def send_bdf_marker(self, marker: str):\n        \"\"\"\n        Send marker to BDF file, can be invoked after `open_bdf_file()`, otherwise it will be ignored.\n\n        Args:\n            marker: marker string to write.\n        \"\"\"\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.write_Annotation(marker)\n\n    def __raise_sock_error(self):\n        if self.__socket_flag == 0:\n            return\n        if self.is_alive():\n            self.close_dev()\n        if self.__socket_flag == 1:\n            raise Exception(\"Device not connected, please connect first.\")\n        elif self.__socket_flag == 2:\n            raise Exception(\"Device connection failed.\")\n        elif self.__socket_flag == 3:\n            raise Exception(\"Data transmission timeout.\")\n        elif self.__socket_flag == 4:\n            raise Exception(\"Data/Impedance mode initialization failed.\")\n        elif self.__socket_flag == 5:\n            raise Exception(\"Heartbeat package sent failed.\")\n        else:\n            raise Exception(f\"Unknown error: {self.__socket_flag}\")\n\n    def run(self):\n        while self.__status not in [iRecorder.Dev.TERMINATE_START]:\n            if self.__status == iRecorder.Dev.SIGNAL_START:\n                self.__recv_data(imp_mode=False)\n            elif self.__status == iRecorder.Dev.IMPEDANCE_START:\n                self.__recv_data(imp_mode=True)\n            elif self.__status in [iRecorder.Dev.IDLE_START]:\n                self.__idle_state()\n            else:\n                print(f\"Unknown status: {self.__status}\")\n                break\n        try:\n            self.dev.close_socket()\n        except Exception:\n            print(\"socket close failed\")\n        finally:\n            self.__status = iRecorder.Dev.TERMINATE\n            print(\"iRecorder disconnected\")\n\n    def __recv_data(self, imp_mode=True):\n        self.__parser.imp_flag = imp_mode\n        retry = 0\n        try:\n            if imp_mode:\n                self.dev.start_impe()\n                self.__status = iRecorder.Dev.IMPEDANCE\n            else:\n                self.dev.start_data()\n                self.__status = iRecorder.Dev.SIGNAL\n        except Exception:\n            print(\"IMPEDANCE/SIGNAL START FAILED!\")\n            self.__socket_flag = 4\n            self.__status = iRecorder.Dev.TERMINATE_START\n\n        print(\"IMPEDANCE/SIGNAL START\")\n        while self.__status in [iRecorder.Dev.SIGNAL, iRecorder.Dev.IMPEDANCE]:\n            try:\n                data = self.dev.recv_socket()\n                if not data:\n                    raise Exception(\"Remote transmission closed.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    self.__save_data.put(ret)\n                    if self.__bdf_flag:\n                        self._bdf_file.write_chunk(ret)\n                    if self.__lsl_flag:\n                        self._lsl_stream.push_chunk(ret)\n            except Exception:\n                if (self.__dev_args[\"type\"] == \"W32\") and (retry &lt; 1):\n                    try:\n                        print(\"Wi-Fi reconnecting...\")\n                        time.sleep(3)\n                        self.dev.close_socket()\n                        self.dev = self.__dev_sock(self.__dev_args, retry_timeout=3)\n                        retry += 1\n                        continue\n                    except Exception:\n                        print(\"Wi-Fi reconnection failed\")\n                self.__socket_flag = 3\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n        # clear buffer\n        self.close_bdf_file()\n        self.close_lsl_stream()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != iRecorder.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == iRecorder.Dev.IDLE_START:\n                    self.__socket_flag = 5\n                self.__status = iRecorder.Dev.TERMINATE_START\n        print(f\"Data thread closed. {datetime.now()}\")\n\n    def __idle_state(self):\n        timestamp = time.time()\n        self.__status = iRecorder.Dev.IDLE\n        while self.__status in [iRecorder.Dev.IDLE]:\n            if (time.time() - timestamp) &lt; 5:\n                time.sleep(0.2)  # to reduce cpu usage\n                continue\n            try:  # heartbeat to keep socket alive and update battery level\n                self.__parser.batt_val = self.dev.send_heartbeat()\n                timestamp = time.time()\n                # print(\"Ah, ah, ah, ah\\nStayin' alive, stayin' alive\")\n            except Exception:\n                # traceback.print_exc()\n                self.__socket_flag = 5\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n    def __get_chs(self) -&gt; int:\n        return int(\"\".join([i for i in self.__dev_args[\"type\"] if i.isdigit()]))\n\n    def __finish_search(self):\n        if self.__interface.is_alive():\n            self.__interface.stop()\n            self.__interface.join()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.__init__","title":"<code>__init__(dev_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dev_type</code> <code>Literal['W8', 'USB8', 'W16', 'USB16', 'W32', 'USB32']</code> <p>iRecorder device type.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if device type not supported.</p> <code>Exception</code> <p>if adapter not available.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def __init__(self, dev_type: Literal[\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"]):\n    \"\"\"\n    Args:\n        dev_type: iRecorder device type.\n\n    Raises:\n        Exception: if device type not supported.\n        Exception: if adapter not available.\n    \"\"\"\n    if dev_type not in {\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"}:\n        raise ValueError(\"Unsupported device type.\")\n    super().__init__(daemon=True, name=f\"iRecorder {dev_type}\")\n    self.__info_q = Queue(128)\n    self.__socket_flag = 1\n    self.__save_data = Queue()\n    self.__status = iRecorder.Dev.TERMINATE\n    self.__lsl_flag = False\n    self.__bdf_flag = False\n    self.__dev_args = {\"type\": dev_type}\n    self.__dev_args.update({\"channel\": self.__get_chs()})\n\n    self.__parser = Parser(self.__dev_args[\"channel\"])\n    self.__interface = get_interface(dev_type)(self.__info_q)\n    self.__dev_sock = get_sock(dev_type)\n    self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n    self.set_frequency()\n    self.update_channels()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_bdf_file","title":"<code>close_bdf_file()</code>","text":"<p>Close and save BDF file manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_bdf_file(self):\n    \"\"\"\n    Close and save BDF file manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__bdf_flag = False\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.close_bdf()\n        del self._bdf_file\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_dev(self) -&gt; None:\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != iRecorder.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iRecorder.Dev.TERMINATE_START\n        while self.__status != iRecorder.Dev.TERMINATE:\n            time.sleep(0.01)\n    self.__finish_search()\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_lsl_stream","title":"<code>close_lsl_stream()</code>","text":"<p>Close LSL stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_lsl_stream(self):\n    \"\"\"\n    Close LSL stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_flag = False\n    if hasattr(self, \"_lsl_stream\"):\n        del self._lsl_stream\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.connect_device","title":"<code>connect_device(addr)</code>","text":"<p>Connect to device by address, block until connection is established or failed.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>device address.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if device already connected or connection failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def connect_device(self, addr: str) -&gt; None:\n    \"\"\"\n    Connect to device by address, block until connection is established or failed.\n\n    Args:\n        addr: device address.\n\n    Raises:\n        Exception: if device already connected or connection failed.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected\")\n    try:\n        ret = self.__interface.connect(addr)\n        self.__dev_args.update({\"name\": addr[-2:], \"sock\": ret})\n        self.__dev_args.update({\"_length\": self.__parser._threshold})\n        self.dev = self.__dev_sock(self.__dev_args)\n        self.__parser.batt_val = self.dev.send_heartbeat()\n        self.__socket_flag = 0\n        self.__info_q.put(True)\n        self.__status = iRecorder.Dev.IDLE_START\n        self.start()\n    except Exception as e:\n        self.__info_q.put(str(e))\n        self.__socket_flag = 2\n        self.__finish_search()\n        raise e\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.find_devs","title":"<code>find_devs(duration=None)</code>","text":"<p>Search for available devices, can only be called once per instance.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[int]</code> <p>Search interval in seconds, blocks for about <code>duration</code> seconds and return found devices, if set to <code>None</code>, return <code>None</code> immediately, devices can later be acquired by calling <code>get_devs()</code> in a loop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>Available devices.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If search thread already running or iRecorder already connected.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n    \"\"\"\n    Search for available devices, can only be called once per instance.\n\n    Args:\n        duration: Search interval in seconds, blocks for about `duration` seconds and return found devices,\n            if set to `None`, return `None` immediately, devices can later be acquired by calling `get_devs()` in a loop.\n\n    Returns:\n        Available devices.\n\n    Raises:\n        Exception: If search thread already running or iRecorder already connected.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected.\")\n    if self.__interface.is_alive():\n        raise Exception(\"Search thread already running.\")\n    self.__interface.start()\n    if duration is None:\n        return\n    start = time.time()\n    while time.time() - start &lt; duration:\n        time.sleep(0.5)\n    self.__finish_search()\n    return self.get_devs()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_available_frequency","title":"<code>get_available_frequency()</code>","text":"<p>Get available sample frequency of device.</p> <p>Returns:</p> Type Description <code>list</code> <p>Available sample frequencies in Hz.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_available_frequency(self) -&gt; list:\n    \"\"\"Get available sample frequency of device.\n\n    Returns:\n        Available sample frequencies in Hz.\n    \"\"\"\n    if \"USB\" in self.__dev_args[\"type\"]:\n        return [500, 1000, 2000]\n    return [500]\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_battery_value","title":"<code>get_battery_value()</code>","text":"<p>Query battery level.</p> <p>Returns:</p> Type Description <code>int</code> <p>battery level in percentage, range from <code>0</code> to <code>100</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_battery_value(self) -&gt; int:\n    \"\"\"\n    Query battery level.\n\n    Returns:\n        battery level in percentage, range from `0` to `100`.\n    \"\"\"\n    return self.__parser.batt_val\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_data","title":"<code>get_data(timeout=0.02)</code>","text":"<p>Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Non-negative value, blocks at most <code>timeout</code> seconds and return, if set to <code>None</code>, blocks until new data is available.</p> <code>0.02</code> <p>Returns:</p> Type Description <code>list[Optional[list]]</code> <p>A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel, eeg channels can be updatd by <code>update_channels()</code>.</p> Data Unit <ul> <li>eeg: microvolts (\u00b5V)</li> <li>triggerbox: int, from <code>0</code> to <code>255</code></li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or in data acquisition mode.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_data(self, timeout: Optional[float] = 0.02) -&gt; list[Optional[list]]:\n    \"\"\"\n    Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n    Args:\n        timeout: Non-negative value, blocks at most `timeout` seconds and return, if set to `None`, blocks until new data is available.\n\n    Returns:\n        A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel,\n            eeg channels can be updatd by `update_channels()`.\n\n    Data Unit:\n        - eeg: microvolts (\u00b5V)\n        - triggerbox: int, from `0` to `255`\n\n    Raises:\n        Exception: if device not connected or in data acquisition mode.\n    \"\"\"\n    if self.__socket_flag:\n        self.__raise_sock_error()\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_info","title":"<code>get_dev_info()</code>","text":"<p>Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing device information, which includes: <code>type</code>: hardware type; <code>channel</code>: hardware channel number; <code>AdapterInfo</code>: adapter used for connection; <code>fs</code>: sample frequency in Hz; <code>ch_info</code>: channel dictionary, including channel index and name, can be altered by <code>update_channels()</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_info(self) -&gt; dict:\n    \"\"\"\n    Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n    Returns:\n        A dictionary containing device information, which includes:\n            `type`: hardware type;\n            `channel`: hardware channel number;\n            `AdapterInfo`: adapter used for connection;\n            `fs`: sample frequency in Hz;\n            `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n    \"\"\"\n    from copy import deepcopy\n\n    return deepcopy(self.__dev_args)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_status","title":"<code>get_dev_status()</code>","text":"<p>Get current device status.</p> <p>Returns:</p> Type Description <code>str</code> <p>\"SIGNAL\": data acquisition mode</p> <code>str</code> <p>\"IMPEDANCE\": impedance acquisition mode</p> <code>str</code> <p>\"IDLE\": idle mode</p> <code>str</code> <p>\"TERMINATE\": device not connected or connection closed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_status(self) -&gt; str:\n    \"\"\"\n    Get current device status.\n\n    Returns:\n        \"SIGNAL\": data acquisition mode\n        \"IMPEDANCE\": impedance acquisition mode\n        \"IDLE\": idle mode\n        \"TERMINATE\": device not connected or connection closed.\n    \"\"\"\n    return self.__status.name\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_devs","title":"<code>get_devs(verbose=False)</code>","text":"<p>Get available devices. This can be called after <code>find_devs(duration = None)</code> in a loop,     each call will only return newly found devices.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>if True, return all available devices information, otherwise only return names for connection, if you don't know what this parameter does, just leave it at its default value.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>Newly found devices.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>adapter not found or not enabled etc.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_devs(self, verbose: bool = False) -&gt; list:\n    \"\"\"\n    Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n        each call will *only* return newly found devices.\n\n    Args:\n        verbose: if True, return all available devices information, otherwise only return names for connection,\n            if you don't know what this parameter does, just leave it at its default value.\n\n    Returns:\n        Newly found devices.\n\n    Raises:\n        Exception: adapter not found or not enabled etc.\n    \"\"\"\n    ret = []\n    time.sleep(0.1)\n    while not self.__info_q.empty():\n        info = self.__info_q.get()\n        if isinstance(info, list):\n            ret.append(info if verbose else info[-1])\n        elif isinstance(info, bool):\n            if verbose:\n                ret.append(info)\n        elif isinstance(info, str):\n            raise Exception(info)\n    return ret\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_impedance","title":"<code>get_impedance()</code>","text":"<p>Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.</p> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>A list of channel impedance ranging from <code>0</code> to <code>np.inf</code> if available, otherwise <code>None</code>.</p> Data Unit <ul> <li>impedance: ohm (\u03a9)</li> </ul> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_impedance(self) -&gt; Optional[list]:\n    \"\"\"\n    Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.\n\n    Returns:\n        A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n    Data Unit:\n        - impedance: ohm (\u03a9)\n    \"\"\"\n    if self.__socket_flag:\n        if self.is_alive():\n            self.close_dev()\n        self.__raise_sock_error()\n    return self.__parser.impedance\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_packet_drop_times","title":"<code>get_packet_drop_times()</code>","text":"<p>Retrieve packet drop times. This value accumulates during data transmission and will be reset to <code>0</code> after device status change.</p> <p>Returns:</p> Type Description <code>int</code> <p>accumulated packet drop times.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_packet_drop_times(self) -&gt; int:\n    \"\"\"\n    Retrieve packet drop times.\n    This value accumulates during data transmission and will be reset to `0` after device status change.\n\n    Returns:\n        accumulated packet drop times.\n    \"\"\"\n    return self.__parser._drop_count\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.open_lsl_stream","title":"<code>open_lsl_stream()</code>","text":"<p>Open LSL stream, can be invoked after <code>start_acquisition_data()</code>,     each frame is the same as described in <code>get_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def open_lsl_stream(self):\n    \"\"\"\n    Open LSL stream, can be invoked after `start_acquisition_data()`,\n        each frame is the same as described in `get_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_stream\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_stream = lslSender(\n        self.__dev_args[\"ch_info\"],\n        f\"iRe{self.__dev_args['type']}{self.__dev_args['name'][-2:]}\",\n        \"EEG\",\n        self.__dev_args[\"fs\"],\n        with_trigger=True,\n    )\n    self.__lsl_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.save_bdf_file","title":"<code>save_bdf_file(filename)</code>","text":"<p>Save data to BDF file, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name to save data, accept absolute or relative path.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or <code>save_bdf_file</code> is invoked and BDF file already created.</p> <code>OSError</code> <p>if BDF file creation failed, this may be caused by invalid file path or permission issue.</p> <code>importError</code> <p>if <code>pyedflib</code> is not installed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def save_bdf_file(self, filename: str):\n    \"\"\"\n    Save data to BDF file, can be invoked after `start_acquisition_data()`.\n\n    Args:\n        filename: file name to save data, accept absolute or relative path.\n\n    Raises:\n        Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n        OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n        importError: if `pyedflib` is not installed.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started\")\n    if hasattr(self, \"_bdf_file\"):\n        raise Exception(\"BDF file already created.\")\n    from ..utils.bdfWrapper import bdfSaver\n\n    if filename[-4:].lower() != \".bdf\":\n        filename += \".bdf\"\n    self._bdf_file = bdfSaver(\n        filename,\n        self.__dev_args[\"ch_info\"],\n        self.__dev_args[\"fs\"],\n        f\"iRecorder {self.__dev_args['type']}\",\n    )\n    self.__bdf_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.send_bdf_marker","title":"<code>send_bdf_marker(marker)</code>","text":"<p>Send marker to BDF file, can be invoked after <code>open_bdf_file()</code>, otherwise it will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>str</code> <p>marker string to write.</p> required Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def send_bdf_marker(self, marker: str):\n    \"\"\"\n    Send marker to BDF file, can be invoked after `open_bdf_file()`, otherwise it will be ignored.\n\n    Args:\n        marker: marker string to write.\n    \"\"\"\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.write_Annotation(marker)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.set_frequency","title":"<code>set_frequency(fs=None)</code>","text":"<p>Update device sample frequency, this method should be invoked before <code>connect_device</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>sample frequency in Hz, if <code>fs</code> is set to <code>None</code> or not in <code>get_available_frequency()</code>, it will fallback to the lowest available frequency.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Device is already connected.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def set_frequency(self, fs: int = None):\n    \"\"\"Update device sample frequency, this method should be invoked before `connect_device`.\n\n    Args:\n        fs: sample frequency in Hz, if `fs` is set to `None` or not in `get_available_frequency()`,\n            it will fallback to the lowest available frequency.\n\n    Raises:\n        Exception: Device is already connected.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"Set frequency failed, device already connected.\")\n    default = self.get_available_frequency()[0]\n    if fs is None:\n        fs = default\n    if fs not in self.get_available_frequency():\n        print(f\"Invalid sample frequency, fallback to {default}Hz\")\n        fs = default\n    self.__dev_args.update({\"fs\": fs})\n    self.__parser._update_fs(fs)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_data","title":"<code>start_acquisition_data()</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or data acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_data(self):\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n\n    Raises:\n        Exception: if device not connected or data acquisition init failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iRecorder.Dev.SIGNAL:\n        return None\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.SIGNAL_START\n    while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.SIGNAL:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_impedance","title":"<code>start_acquisition_impedance()</code>","text":"<p>Send impedance acquisition command to device, block until data acquisition started or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or impedance acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_impedance(self) -&gt; None:\n    \"\"\"\n    Send impedance acquisition command to device, block until data acquisition started or failed.\n\n    Raises:\n        Exception: if device not connected or impedance acquisition init failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        return None\n    if self.__status == iRecorder.Dev.SIGNAL:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.IMPEDANCE_START\n    while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.IMPEDANCE:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or acquisition stop failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n    Raises:\n        Exception: if device not connected or acquisition stop failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    self.__status = iRecorder.Dev.IDLE_START\n    while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.IDLE:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.update_channels","title":"<code>update_channels(channels=None)</code>","text":"<p>update channel information, valid only when device is not acquiring data or impedance.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[dict]</code> <p>channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"}, if <code>None</code> is given, reset to all available channels with default names.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if data/impedance acquisition in progress.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def update_channels(self, channels: Optional[dict] = None):\n    \"\"\"\n    update channel information, valid only when device is not acquiring data or impedance.\n\n    Args:\n        channels: channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"},\n            if `None` is given, reset to all available channels with default names.\n\n    Raises:\n        Exception: if data/impedance acquisition in progress.\n    \"\"\"\n    if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        raise Exception(\n            \"Device acquisition in progress, please `stop_acquisition` first.\"\n        )\n    if channels is None:\n        from .default_config import getChannels\n\n        channels = getChannels(self.__dev_args[\"channel\"])\n    self.__dev_args.update({\"ch_info\": channels})\n    ch_idx = [i for i in channels.keys()]\n    self.__parser.update_chs(ch_idx)\n</code></pre>"},{"location":"lightStimulator/","title":"Light Stimulator","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class lightStimulator:\n    def __init__(self, port: str = None):\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        self.wait_time = 0.1\n        self.channels = 6\n\n        if not port:\n            for ports in comports():\n                if (\n                    ports.pid == 0x6001\n                    and ports.vid == 0x0403\n                    and ports.serial_number in [\"LIGHTSTIMA\", \"LIGHTSTIM\"]\n                ):\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Light stimulator not found\")\n        self.dev = Serial(port, baudrate=115200, timeout=2)\n        self.dev.read_all()\n\n    def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n        \"\"\"\n        Enter VEP mode, which allows you to control the frequency of each channel separately.\n\n        Args:\n            fs: List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n                If a corresponding frequency is None, 0  or not given, it will be set to off.\n\n        Raises:\n            Exception: If the frequency is invalid or hardware error.\n        \"\"\"\n        fss = fs.copy()\n        if len(fss) &lt; self.channels:\n            fss += [0] * (self.channels - len(fss))\n        for i in range(self.channels):\n            fss[i] = self._validate_fs(fss[i])\n        command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n        command = f\"AT+VEP={command}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        print(ret)\n        if b\"SSVEP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def erp_mode(self, fs: float):\n        \"\"\"\n        Enter ERP mode, which allows you to control the frequency of all channels at once.\n\n        Args:\n            fs: Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.\n\n        Raises:\n            Exception: If the frequency is invalid or hardware error.\n        \"\"\"\n        fs = self._validate_fs(fs)\n        command = f\"AT+ERP={fs:.1f}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        print(ret)\n        if b\"ERP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def _validate_fs(self, fs: float):\n        if not isinstance(fs, (int, float)):\n            if fs is None:\n                fs = 0\n            else:\n                raise Exception(\"Invalid frequency\")\n        if fs &gt; 100 or fs &lt; 0:\n            raise Exception(\"Invalid frequency\")\n        return fs\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"lightStimulator/#eConEXG.lightStimulator.erp_mode","title":"<code>erp_mode(fs)</code>","text":"<p>Enter ERP mode, which allows you to control the frequency of all channels at once.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>float</code> <p>Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the frequency is invalid or hardware error.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def erp_mode(self, fs: float):\n    \"\"\"\n    Enter ERP mode, which allows you to control the frequency of all channels at once.\n\n    Args:\n        fs: Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.\n\n    Raises:\n        Exception: If the frequency is invalid or hardware error.\n    \"\"\"\n    fs = self._validate_fs(fs)\n    command = f\"AT+ERP={fs:.1f}\\r\\n\".encode()\n    self.dev.write(command)\n    time.sleep(self.wait_time)\n    ret = self.dev.read_all()\n    print(ret)\n    if b\"ERP MODE OK\" not in ret:\n        raise Exception(\"Failed to set VEP mode\")\n</code></pre>"},{"location":"lightStimulator/#eConEXG.lightStimulator.vep_mode","title":"<code>vep_mode(fs=[1, 1, 1, 1, 1, 1])</code>","text":"<p>Enter VEP mode, which allows you to control the frequency of each channel separately.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>list[Optional[float]]</code> <p>List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution. If a corresponding frequency is None, 0  or not given, it will be set to off.</p> <code>[1, 1, 1, 1, 1, 1]</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the frequency is invalid or hardware error.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n    \"\"\"\n    Enter VEP mode, which allows you to control the frequency of each channel separately.\n\n    Args:\n        fs: List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n            If a corresponding frequency is None, 0  or not given, it will be set to off.\n\n    Raises:\n        Exception: If the frequency is invalid or hardware error.\n    \"\"\"\n    fss = fs.copy()\n    if len(fss) &lt; self.channels:\n        fss += [0] * (self.channels - len(fss))\n    for i in range(self.channels):\n        fss[i] = self._validate_fs(fss[i])\n    command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n    command = f\"AT+VEP={command}\\r\\n\".encode()\n    self.dev.write(command)\n    time.sleep(self.wait_time)\n    ret = self.dev.read_all()\n    print(ret)\n    if b\"SSVEP MODE OK\" not in ret:\n        raise Exception(\"Failed to set VEP mode\")\n</code></pre>"},{"location":"triggerBoxWire/","title":"Wired","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWired:\n    def __init__(self, port: str = None):\n        \"\"\"\n        Args:\n            port: The serial port of the trigger box. If not given,\n                the function will try to find the trigger box automatically.\n\n        Raises:\n            Exception: If the trigger box is not found.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            for ports in comports():\n                if ports.pid == 0x5740 and ports.vid == 0x0483:\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Trigger box not found\")\n        self.dev = Serial(port, timeout=1)\n\n    def sendMarker(self, marker: int):\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        self.dev.write(marker.to_bytes())\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWire/#eConEXG.triggerBoxWired.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the trigger box is not found.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port: str = None):\n    \"\"\"\n    Args:\n        port: The serial port of the trigger box. If not given,\n            the function will try to find the trigger box automatically.\n\n    Raises:\n        Exception: If the trigger box is not found.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        for ports in comports():\n            if ports.pid == 0x5740 and ports.vid == 0x0483:\n                port = ports.device\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n    self.dev = Serial(port, timeout=1)\n</code></pre>"},{"location":"triggerBoxWireless/","title":"Wireless","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWireless:\n    def __init__(self, port: str = None):\n        \"\"\"\n        Args:\n            port: The serial port of the trigger box. If not given,\n                the function will try to find the trigger box automatically.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            for ports in comports():\n                if ports.pid == 0x6001 and ports.vid == 0x0403:\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Trigger box not found\")\n        self.dev = Serial(port, baudrate=115200, timeout=1)\n        self.__last_timestamp = time.perf_counter()\n        self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n        time.sleep(0.1)\n\n    def sendMarker(self, marker: int):\n        \"\"\"\n        Send a marker to the trigger box.\n\n        Parameters\n        ----------\n            marker : int\n                range from `1` to `255`, `13` is not available and reserved for internal use.\n        \"\"\"\n        if time.perf_counter() - self.__last_timestamp &lt; 0.045:\n            print(self.__warn)\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        self.dev.write(marker.to_bytes() + b\"\\x55\\x66\\x0d\")\n        self.__last_timestamp = time.perf_counter()\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.</p> <code>None</code> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port: str = None):\n    \"\"\"\n    Args:\n        port: The serial port of the trigger box. If not given,\n            the function will try to find the trigger box automatically.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        for ports in comports():\n            if ports.pid == 0x6001 and ports.vid == 0x0403:\n                port = ports.device\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n    self.dev = Serial(port, baudrate=115200, timeout=1)\n    self.__last_timestamp = time.perf_counter()\n    self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n    time.sleep(0.1)\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.sendMarker","title":"<code>sendMarker(marker)</code>","text":"<p>Send a marker to the trigger box.</p>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.sendMarker--parameters","title":"Parameters","text":"<pre><code>marker : int\n    range from `1` to `255`, `13` is not available and reserved for internal use.\n</code></pre> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def sendMarker(self, marker: int):\n    \"\"\"\n    Send a marker to the trigger box.\n\n    Parameters\n    ----------\n        marker : int\n            range from `1` to `255`, `13` is not available and reserved for internal use.\n    \"\"\"\n    if time.perf_counter() - self.__last_timestamp &lt; 0.045:\n        print(self.__warn)\n    if not isinstance(marker, int):\n        marker = int(marker)\n    if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n        raise Exception(\"Invalid marker\")\n    self.dev.write(marker.to_bytes() + b\"\\x55\\x66\\x0d\")\n    self.__last_timestamp = time.perf_counter()\n</code></pre>"}]}
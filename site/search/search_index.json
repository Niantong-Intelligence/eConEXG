{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to eConEXG's documentation.","text":"<p>for full infomation, please visit our Github repository.</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li> <p>Online: (will be available soon)</p> <p><code>pip install econexg</code></p> </li> <li> <p>Offline:</p> <p><code>pip install econexg-x.x.x-py3-none-any.whl</code></p> </li> </ul>"},{"location":"#optional-dependencies-bdf-and-lsl-can-be-installed-using","title":"Optional dependencies <code>bdf</code> and <code>lsl</code> can be installed using:","text":"<p><code>pip install econexg[option1,option2]</code></p>"},{"location":"#more","title":"More","text":"<ul> <li>Discussion Forum, to discuss the project   on GitHub</li> <li>Issue Tracker, if you run into bugs or have suggestions</li> <li>License: MIT</li> </ul>"},{"location":"about/","title":"About","text":"<p>StatusCode        : 200 StatusDescription : OK Content           : # Orta comitata poenas quia crudelis animo foedataque</p> <pre><code>                ## Daedale nunc armis fuerant lecturum\n\n                Lorem markdownum rursus, via regnat conparentis mittor ignorans te audacia\n                lapillo et Paris iuvenci, indi...\n</code></pre> <p>RawContent        : HTTP/1.1 200 OK                     Transfer-Encoding: chunked                     Connection: keep-alive                     access-control-allow-origin: *                     Content-Type: text/plain; charset=utf-8                     Date: Mon, 27 May 2024 08:21:20 GMT                     Server: nginx/1.14.2... Forms             : {} Headers           : {[Transfer-Encoding, chunked], [Connection, keep-alive], [access-control-allow-origin, *], [Content-Type, text/plain; charset=utf-8]...} Images            : {} InputFields       : {} Links             : {} ParsedHtml        : mshtml.HTMLDocumentClass RawContentLength  : 3063</p>"},{"location":"iFocus/","title":"iFocus","text":""},{"location":"iFocus/#eConEXG.iFocus.iFocus","title":"<code>iFocus</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>class iFocus(Thread):\n    class Dev(Enum):\n        SIGNAL = 10\n        SIGNAL_START = 11\n        IDLE = 30\n        IDLE_START = 31\n        TERMINATE = 40\n        TERMINATE_START = 41\n\n    def __init__(self, port: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Args:\n            port: if not given, connect to the first available device\n        \"\"\"\n        super().__init__(daemon=True)\n        if port is None:\n            port = iFocus.find_devs()[0]\n        self.__save_data = Queue()\n        self.__parser = Parser()\n        self.dev = sock(port)\n        self.__socket_flag = 1\n        try:\n            self.dev.connect_socket()\n        except Exception as e:\n            try:\n                self.dev.close_socket()\n            finally:\n                raise e\n        self.__status = iFocus.Dev.IDLE_START\n        self.__socket_flag = 0\n        self.start()\n\n    @staticmethod\n    def find_devs() -&gt; list:\n        \"\"\"\n        Find available iFocus devices.\n\n        Returns:\n            available device ports.\n\n        Raises:\n            Exception: if no iFocus device found.\n        \"\"\"\n        from serial.tools.list_ports import comports\n\n        ret = []\n        devices = comports()\n        for device in devices:\n            if \"FTDI\" in device.manufacturer:\n                if device.serial_number in [\"IFOCUSA\", \"iFocus\"]:\n                    ret.append(device.device)\n        if len(ret) == 0:\n            raise Exception(\"iFocus device not found\")\n        return ret\n\n    def get_data(self, timeout: Optional[float] = None) -&gt; list[Optional[list]]:\n        \"\"\"\n        Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.\n\n        Args:\n            timeout: it blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n        Returns:\n            A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below:\n                [[`eeg_0`], [`eeg_1`], [`eeg_2`], [`eeg_3`], [`eeg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                    in which number `0~4` after `_` indicates the time order of channel data.\n\n        Raises:\n            Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n        Data Unit:\n            - eeg: \u00b5V\n            - imu: degree(\u00b0)\n        \"\"\"\n        if self.__socket_flag:\n            self.__raise_sock_error()\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def start_acquisition_data(self) -&gt; None:\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n        \"\"\"\n        if self.__status == iFocus.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iFocus.Dev.SIGNAL:\n            return\n        self.__status = iFocus.Dev.SIGNAL_START\n        while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iFocus.Dev.SIGNAL:\n            self.__raise_sock_error()\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n        \"\"\"\n        if self.__status == iFocus.Dev.TERMINATE:\n            self.__raise_sock_error()\n        self.__status = iFocus.Dev.IDLE_START\n        while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iFocus.Dev.IDLE:\n            self.__raise_sock_error()\n\n    def close_dev(self):\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != iFocus.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iFocus.Dev.TERMINATE_START\n            while self.__status != iFocus.Dev.TERMINATE:\n                time.sleep(0.1)\n        if self.is_alive():\n            self.join()\n\n    def __recv_data(self):\n        try:\n            self.dev.start_data()\n            self.__status = iFocus.Dev.SIGNAL\n        except Exception:\n            print(\"SIGNAL START FAILED!\")\n            self.__socket_flag = 4\n            self.__status = iFocus.Dev.TERMINATE_START\n\n        print(\"SIGNAL START\")\n        while self.__status in [iFocus.Dev.SIGNAL]:\n            try:\n                data = self.dev.recv_socket()\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    self.__save_data.put(ret)\n            except Exception:\n                traceback.print_exc()\n                self.__socket_flag = 3\n                self.__status = iFocus.Dev.TERMINATE_START\n\n        # clear buffer\n        self.dev.stop_recv()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != iFocus.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == iFocus.Dev.IDLE_START:\n                    self.__socket_flag = 5\n                self.__status = iFocus.Dev.TERMINATE_START\n        print(\"Data thread closed\")\n\n    def run(self):\n        print(\"iFocus connected\")\n        while self.__status != iFocus.Dev.TERMINATE_START:\n            if self.__status == iFocus.Dev.SIGNAL_START:\n                self.__recv_data()\n            elif self.__status == iFocus.Dev.IDLE_START:\n                self.__status = iFocus.Dev.IDLE\n                while self.__status == iFocus.Dev.IDLE:\n                    time.sleep(0.1)\n            else:\n                print(f\"Unknown status: {self.__status}\")\n                break\n        try:\n            self.dev.close_socket()\n        except Exception:\n            print(\"socket close failed\")\n        finally:\n            self.__status = iFocus.Dev.TERMINATE\n            print(\"iFocus disconnected\")\n\n    def __raise_sock_error(self):\n        if self.__socket_flag == 0:\n            return\n        if self.is_alive():\n            self.close_dev()\n        if self.__socket_flag == 1:\n            raise Exception(\"Device not connected, please connect first.\")\n        elif self.__socket_flag == 2:\n            raise Exception(\"Device connection failed.\")\n        elif self.__socket_flag == 3:\n            raise Exception(\"Data transmission timeout.\")\n        elif self.__socket_flag == 4:\n            raise Exception(\"Data/Impedance mode initialization failed.\")\n        else:\n            raise Exception(f\"Unknown error: {self.__socket_flag}\")\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>if not given, connect to the first available device</p> <code>None</code> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def __init__(self, port: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Args:\n        port: if not given, connect to the first available device\n    \"\"\"\n    super().__init__(daemon=True)\n    if port is None:\n        port = iFocus.find_devs()[0]\n    self.__save_data = Queue()\n    self.__parser = Parser()\n    self.dev = sock(port)\n    self.__socket_flag = 1\n    try:\n        self.dev.connect_socket()\n    except Exception as e:\n        try:\n            self.dev.close_socket()\n        finally:\n            raise e\n    self.__status = iFocus.Dev.IDLE_START\n    self.__socket_flag = 0\n    self.start()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_dev(self):\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != iFocus.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iFocus.Dev.TERMINATE_START\n        while self.__status != iFocus.Dev.TERMINATE:\n            time.sleep(0.1)\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.find_devs","title":"<code>find_devs()</code>  <code>staticmethod</code>","text":"<p>Find available iFocus devices.</p> <p>Returns:</p> Type Description <code>list</code> <p>available device ports.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if no iFocus device found.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>@staticmethod\ndef find_devs() -&gt; list:\n    \"\"\"\n    Find available iFocus devices.\n\n    Returns:\n        available device ports.\n\n    Raises:\n        Exception: if no iFocus device found.\n    \"\"\"\n    from serial.tools.list_ports import comports\n\n    ret = []\n    devices = comports()\n    for device in devices:\n        if \"FTDI\" in device.manufacturer:\n            if device.serial_number in [\"IFOCUSA\", \"iFocus\"]:\n                ret.append(device.device)\n    if len(ret) == 0:\n        raise Exception(\"iFocus device not found\")\n    return ret\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.get_data","title":"<code>get_data(timeout=None)</code>","text":"<p>Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>it blocks at most 'timeout' seconds and return, if set to <code>None</code>, blocks until new data available.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Optional[list]]</code> <p>A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below: [[<code>eeg_0</code>], [<code>eeg_1</code>], [<code>eeg_2</code>], [<code>eeg_3</code>], [<code>eeg_4</code>], [<code>imu_x</code>, <code>imu_y</code>, <code>imu_z</code>]],     in which number <code>0~4</code> after <code>_</code> indicates the time order of channel data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected, connection failed, data transmission timeout/init failed, or unknown error.</p> Data Unit <ul> <li>eeg: \u00b5V</li> <li>imu: degree(\u00b0)</li> </ul> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def get_data(self, timeout: Optional[float] = None) -&gt; list[Optional[list]]:\n    \"\"\"\n    Acquire iFocus data, make sure this function is called in a loop so that it can continuously read the data.\n\n    Args:\n        timeout: it blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n    Returns:\n        A list of frames, each frame is made up of 5 eeg data and 1 imu data in a shape as below:\n            [[`eeg_0`], [`eeg_1`], [`eeg_2`], [`eeg_3`], [`eeg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                in which number `0~4` after `_` indicates the time order of channel data.\n\n    Raises:\n        Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n    Data Unit:\n        - eeg: \u00b5V\n        - imu: degree(\u00b0)\n    \"\"\"\n    if self.__socket_flag:\n        self.__raise_sock_error()\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.start_acquisition_data","title":"<code>start_acquisition_data()</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def start_acquisition_data(self) -&gt; None:\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n    \"\"\"\n    if self.__status == iFocus.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iFocus.Dev.SIGNAL:\n        return\n    self.__status = iFocus.Dev.SIGNAL_START\n    while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iFocus.Dev.SIGNAL:\n        self.__raise_sock_error()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n    \"\"\"\n    if self.__status == iFocus.Dev.TERMINATE:\n        self.__raise_sock_error()\n    self.__status = iFocus.Dev.IDLE_START\n    while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iFocus.Dev.IDLE:\n        self.__raise_sock_error()\n</code></pre>"},{"location":"iRecorder/","title":"iRecorder","text":""},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder","title":"<code>iRecorder</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>class iRecorder(Thread):\n    class Dev(Enum):\n        SIGNAL = 10  # signal transmision mode\n        SIGNAL_START = 11\n        IMPEDANCE = 20  # impedance transmision mode\n        IMPEDANCE_START = 21\n        IDLE = 30  # idle mode\n        IDLE_START = 31\n        TERMINATE = 40  # Init state\n        TERMINATE_START = 41\n\n    def __init__(self, dev_type: Literal[\"W8\", \"W16\", \"W32\", \"USB32\"]):\n        \"\"\"\n        Args:\n            dev_type: iRecorder device type.\n\n        Raises:\n            Exception: if device type not supported.\n            Exception: if adapter not available.\n        \"\"\"\n        super().__init__(daemon=True, name=\"iRecorder\")\n        self.__info_q = Queue(128)\n        self.__socket_flag = 1\n        self.__save_data = Queue()\n        self.__status = iRecorder.Dev.TERMINATE\n        self.__lsl_flag = False\n        self.__bdf_flag = False\n        self.__dev_args = {\"type\": dev_type}\n        self.__dev_args.update({\"channel\": self.__get_chs()})\n\n        self.__parser = Parser(self.__dev_args[\"channel\"])\n        self.__interface = get_interface(dev_type)(self.__info_q)\n        self.__dev_sock = get_sock(dev_type)\n        self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n        self.set_frequency()\n        self.update_channels()\n\n    def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n        \"\"\"\n        Search for available devices, can only be called once per instance.\n\n        Args:\n            duration: Search interval in seconds, blocks for about `duration` seconds and return found devices.\n\n        Returns:\n            Available devices. If `duration` is set to `None` it will return `None` immediately, \n                devices can later be acquired by calling `get_devs()` in a loop.\n\n        Raises:\n            Exception: If search thread already running or iRecorder already connected.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected.\")\n        if self.__interface.is_alive():\n            raise Exception(\"Search thread already running.\")\n        self.__interface.start()\n        if duration is None:\n            return\n        start = time.time()\n        while time.time() - start &lt; duration:\n            time.sleep(0.5)\n        self.__finish_search()\n        return self.get_devs()\n\n    def get_devs(self, verbose: bool = False) -&gt; list:\n        \"\"\"\n        Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n            each call will *only* return newly found devices.\n\n        Args:\n            verbose: if True, return all available devices information, otherwise only return names for connection,\n                if you don't know what this parameter does, just leave it at its default value.\n\n        Returns:\n            Newly found devices.\n\n        Raises:\n            Exception: adapter not found or not enabled etc.\n        \"\"\"\n        ret = []\n        while not self.__info_q.empty():\n            info = self.__info_q.get()\n            if isinstance(info, list):\n                ret.append(info if verbose else info[-1])\n            elif isinstance(info, bool):\n                if verbose:\n                    ret.append(info)\n            elif isinstance(info, str):\n                raise Exception(info)\n        return ret\n\n    def get_dev_status(self) -&gt; str:\n        \"\"\"\n        Get current device status.\n\n        Returns:\n            SIGNAL: data acquisition mode\n            IMPEDANCE: impedance acquisition mode\n            IDLE: idle mode\n            TERMINATE: device not connected or connection closed.\n        \"\"\"\n        return self.__status.name\n\n    def get_dev_info(self) -&gt; dict:\n        \"\"\"\n        Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n        Returns:\n            A dictionary containing device information, which includes:\n                `type`: hardware type;\n                `channel`: hardware channel number;\n                `AdapterInfo`: adapter used for connection;\n                `fs`: sample frequency in Hz;\n                `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self.__dev_args)\n\n    def get_available_frequency(self) -&gt; list:\n        \"\"\"Get available sample frequency of device.\n\n        Returns:\n            Available sample frequencies in Hz.\n        \"\"\"\n        if self.__dev_args[\"type\"] == \"USB32\":\n            return [500, 1000, 2000]\n        else:\n            return [500]\n\n    def set_frequency(self, fs: int = None):\n        \"\"\"Update device sample frequency, can only be invoked before `connect_device`.\n\n        Args:\n            fs: sample frequency in Hz, if `None` or fs not in `get_available_frequency()`, \n                it will fallback to the lowest available frequency.\n\n        Raises:\n            Exception: if device already connected.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"Already connected to device\")\n        default = self.get_available_frequency()[0]\n        if fs is None:\n            fs = default\n        if fs not in self.get_available_frequency():\n            print(f\"Invalid sample frequency, fallback to {default}Hz\")\n            fs = default\n        self.__dev_args.update({\"fs\": fs})\n        self.__parser._update_fs(fs)\n\n    def connect_device(self, addr: str) -&gt; None:\n        \"\"\"\n        Connect to device by address, block until connection is established or failed.\n\n        Args:\n            addr: device address.\n\n        Raises:\n            Exception: if device already connected or connection failed.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected\")\n        try:\n            ret = self.__interface.connect(addr)\n            self.__dev_args.update({\"name\": addr[-2:], \"sock\": ret})\n            self.dev = self.__dev_sock(self.__dev_args)\n            self.__parser.batt_val = self.dev.send_heartbeat()\n            self.__socket_flag = 0\n            self.__info_q.put(True)\n            self.__status = iRecorder.Dev.IDLE_START\n            self.start()\n        except Exception as e:\n            self.__info_q.put(str(e))\n            self.__socket_flag = 2\n            self.__finish_search()\n            raise e\n\n    def update_channels(self, channels: Optional[dict] = None):\n        \"\"\"\n        update channel information, valid only when device stopped acquisition.\n        channel number is 0 based.\n\n        Args:\n            channels: channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"},\n                if `None` is given, all channels availabel will be used with default values.\n\n        Raises:\n            Exception: if data/impedance acquisition in progress.\n        \"\"\"\n        if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            raise Exception(\n                \"Device acquisition in progress, please `stop_acquisition` first.\"\n            )\n        if channels is None:\n            from .default_config import getChannels\n\n            channels = getChannels(self.__dev_args[\"channel\"])\n        self.__dev_args.update({\"ch_info\": channels})\n        ch_idx = [i for i in channels.keys()]\n        self.__parser.update_chs(ch_idx)\n\n    def start_acquisition_data(self):\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n\n        Raises:\n            Exception: if device not connected or data acquisition init failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iRecorder.Dev.SIGNAL:\n            return None\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.SIGNAL_START\n        while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.SIGNAL:\n            self.__raise_sock_error()\n        return None\n\n    def get_data(self, timeout: Optional[float] = None) -&gt; list[Optional[list]]:\n        \"\"\"\n        Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n        Args:\n            timeout: it blocks at most `timeout` seconds and return, otherwise it returns until new data is available.\n\n        Returns:\n            A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel, \n                eeg channels can be updatd by `update_channels()`.\n\n        Data Unit:\n            - eeg: microvolts (\u00b5V)\n            - triggerbox: int, from `0` to `255`\n\n        \"\"\"\n        if self.__socket_flag:\n            self.__raise_sock_error()\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n        Raises:\n            Exception: if device not connected or acquisition stop failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        self.__status = iRecorder.Dev.IDLE_START\n        while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.IDLE:\n            self.__raise_sock_error()\n        return None\n\n    def start_acquisition_impedance(self) -&gt; None:\n        \"\"\"\n        Send impedance acquisition command to device, block until data acquisition started or failed.\n\n        Raises:\n            Exception: if device not connected or impedance acquisition init failed.\n        \"\"\"\n        if self.__status == iRecorder.Dev.TERMINATE:\n            self.__raise_sock_error()\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            return None\n        if self.__status == iRecorder.Dev.SIGNAL:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.IMPEDANCE_START\n        while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != iRecorder.Dev.IMPEDANCE:\n            self.__raise_sock_error()\n        return None\n\n    def get_impedance(self) -&gt; Optional[list]:\n        \"\"\"\n        Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.\n\n        Returns:\n            A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n        Data Unit:\n            - impedance: ohm (\u03a9)\n        \"\"\"\n        if self.__socket_flag:\n            if self.is_alive():\n                self.close_dev()\n            self.__raise_sock_error()\n        return self.__parser.impedance\n\n    def close_dev(self) -&gt; None:\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != iRecorder.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iRecorder.Dev.TERMINATE_START\n            while self.__status != iRecorder.Dev.TERMINATE:\n                time.sleep(0.01)\n        self.__finish_search()\n        if self.is_alive():\n            self.join()\n\n    def get_packet_drop_times(self) -&gt; int:\n        \"\"\"\n        Retrieve packet drop times.\n        This value accumulates during data transmission and will be reset to `0` after device status change.\n\n        Returns:\n            accumulated packet drop times.\n        \"\"\"\n        return self.__parser._drop_count\n\n    def get_battery_value(self) -&gt; int:\n        \"\"\"\n        Query battery level.\n\n        Returns:\n            battery level in percentage, range from `0` to `100`.\n        \"\"\"\n        return self.__parser.batt_val\n\n    def open_lsl_stream(self):\n        \"\"\"\n        Open LSL stream, can be invoked after `start_acquisition_data()`,\n            each frame is the same as described in `get_data()`. \n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_stream\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_stream = lslSender(\n            self.__dev_args[\"ch_info\"],\n            f\"iRe{self.__dev_args['type']}_{self.__dev_args['name']}\",\n            \"EEG\",\n            self.__dev_args[\"fs\"],\n            with_trigger=True,\n        )\n        self.__lsl_flag = True\n\n    def close_lsl_stream(self):\n        \"\"\"\n        Close LSL stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_flag = False\n        if hasattr(self, \"_lsl_stream\"):\n            del self._lsl_stream\n\n    def save_bdf_file(self, filename: str):\n        \"\"\"\n        Save data to BDF file, can be invoked after `start_acquisition_data()`.\n\n        Args:\n            filename: file name to save data, accept absolute or relative path.\n\n        Raises:\n            Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n            OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n            importError: if `pyedflib` is not installed.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started\")\n        if hasattr(self, \"_bdf_file\"):\n            raise Exception(\"BDF file already created.\")\n        from ..utils.bdfWrapper import bdfSaver\n\n        if filename[-4:].lower() != \".bdf\":\n            filename += \".bdf\"\n        self._bdf_file = bdfSaver(\n            filename,\n            self.__dev_args[\"ch_info\"],\n            self.__dev_args[\"fs\"],\n            f\"iRecorder{self.__dev_args['type']}\",\n        )\n        self.__bdf_flag = True\n\n    def close_bdf_file(self):\n        \"\"\"\n        Close and save BDF file manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__bdf_flag = False\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.close_bdf()\n            del self._bdf_file\n\n    def send_bdf_marker(self, marker: str):\n        \"\"\"\n        Send marker to BDF file, can be invoked after `open_bdf_file()`, otherwise it will be ignored.\n\n        Args:\n            marker: marker string to write.\n        \"\"\"\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.write_Annotation(marker)\n\n    def __raise_sock_error(self):\n        if self.__socket_flag == 0:\n            return\n        if self.is_alive():\n            self.close_dev()\n        if self.__socket_flag == 1:\n            raise Exception(\"Device not connected, please connect first.\")\n        elif self.__socket_flag == 2:\n            raise Exception(\"Device connection failed.\")\n        elif self.__socket_flag == 3:\n            raise Exception(\"Data transmission timeout.\")\n        elif self.__socket_flag == 4:\n            raise Exception(\"Data/Impedance mode initialization failed.\")\n        elif self.__socket_flag == 5:\n            raise Exception(\"Heartbeat package sent failed.\")\n        else:\n            raise Exception(f\"Unknown error: {self.__socket_flag}\")\n\n    def run(self):\n        while self.__status not in [iRecorder.Dev.TERMINATE_START]:\n            if self.__status == iRecorder.Dev.SIGNAL_START:\n                self.__recv_data(imp_mode=False)\n            elif self.__status == iRecorder.Dev.IMPEDANCE_START:\n                self.__recv_data(imp_mode=True)\n            elif self.__status in [iRecorder.Dev.IDLE_START]:\n                self.__idle_state()\n            else:\n                print(f\"Unknown status: {self.__status}\")\n                break\n        try:\n            self.dev.close_socket()\n        except Exception:\n            print(\"socket close failed\")\n        finally:\n            self.__status = iRecorder.Dev.TERMINATE\n            print(\"iRecorder disconnected\")\n\n    def __recv_data(self, imp_mode=True):\n        self.__parser.imp_flag = imp_mode\n        retry = 0\n        try:\n            if imp_mode:\n                self.dev.start_impe()\n                self.__status = iRecorder.Dev.IMPEDANCE\n            else:\n                self.dev.start_data()\n                self.__status = iRecorder.Dev.SIGNAL\n        except Exception:\n            print(\"IMPEDANCE/SIGNAL START FAILED!\")\n            self.__socket_flag = 4\n            self.__status = iRecorder.Dev.TERMINATE_START\n\n        print(\"IMPEDANCE/SIGNAL START\")\n        while self.__status in [iRecorder.Dev.SIGNAL, iRecorder.Dev.IMPEDANCE]:\n            try:\n                data = self.dev.recv_socket()\n                if not data:\n                    raise Exception(\"Remote transmission closed.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    self.__save_data.put(ret)\n                    if self.__bdf_flag:\n                        self._bdf_file.write_chuck(ret)\n                    if self.__lsl_flag:\n                        self._lsl_stream.push_chuck(ret)\n            except Exception:\n                traceback.print_exc()\n                if (self.__dev_args[\"type\"] == \"W32\") and (retry &lt; 1):\n                    try:\n                        print(\"Wi-Fi reconnecting...\")\n                        time.sleep(3)\n                        self.dev.close_socket()\n                        self.dev = self.__dev_sock(self.__dev_args, retry_timeout=2)\n                        retry += 1\n                        continue\n                    except Exception:\n                        print(\"Wi-Fi reconnection failed\")\n                self.__socket_flag = 3\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n        # clear buffer\n        self.close_bdf_file()\n        self.close_lsl_stream()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != iRecorder.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == iRecorder.Dev.IDLE_START:\n                    self.__socket_flag = 5\n                self.__status = iRecorder.Dev.TERMINATE_START\n        print(\"Data thread closed\")\n\n    def __idle_state(self):\n        timestamp = time.time()\n        self.__status = iRecorder.Dev.IDLE\n        while self.__status in [iRecorder.Dev.IDLE]:\n            if (time.time() - timestamp) &lt; 5:\n                time.sleep(0.2)  # to reduce cpu usage\n                continue\n            try:  # heartbeat to keep socket alive and update battery level\n                self.__parser.batt_val = self.dev.send_heartbeat()\n                timestamp = time.time()\n                # print(\"Ah, ah, ah, ah\\nStayin' alive, stayin' alive\")\n            except Exception:\n                traceback.print_exc()\n                self.__socket_flag = 5\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n    def __get_chs(self) -&gt; int:\n        dev_type = self.__dev_args[\"type\"]\n        if dev_type == \"W8\":\n            return 8\n        elif dev_type == \"W16\":\n            return 16\n        elif dev_type == \"W32\":\n            return 32\n        elif dev_type == \"USB32\":\n            return 32\n        else:\n            raise ValueError(\"Invalid device type\")\n\n    def __finish_search(self):\n        if self.__interface.is_alive():\n            self.__interface.stop()\n            self.__interface.join()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.__init__","title":"<code>__init__(dev_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dev_type</code> <code>Literal['W8', 'W16', 'W32', 'USB32']</code> <p>iRecorder device type.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if device type not supported.</p> <code>Exception</code> <p>if adapter not available.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def __init__(self, dev_type: Literal[\"W8\", \"W16\", \"W32\", \"USB32\"]):\n    \"\"\"\n    Args:\n        dev_type: iRecorder device type.\n\n    Raises:\n        Exception: if device type not supported.\n        Exception: if adapter not available.\n    \"\"\"\n    super().__init__(daemon=True, name=\"iRecorder\")\n    self.__info_q = Queue(128)\n    self.__socket_flag = 1\n    self.__save_data = Queue()\n    self.__status = iRecorder.Dev.TERMINATE\n    self.__lsl_flag = False\n    self.__bdf_flag = False\n    self.__dev_args = {\"type\": dev_type}\n    self.__dev_args.update({\"channel\": self.__get_chs()})\n\n    self.__parser = Parser(self.__dev_args[\"channel\"])\n    self.__interface = get_interface(dev_type)(self.__info_q)\n    self.__dev_sock = get_sock(dev_type)\n    self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n    self.set_frequency()\n    self.update_channels()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_bdf_file","title":"<code>close_bdf_file()</code>","text":"<p>Close and save BDF file manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_bdf_file(self):\n    \"\"\"\n    Close and save BDF file manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__bdf_flag = False\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.close_bdf()\n        del self._bdf_file\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_dev(self) -&gt; None:\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != iRecorder.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iRecorder.Dev.TERMINATE_START\n        while self.__status != iRecorder.Dev.TERMINATE:\n            time.sleep(0.01)\n    self.__finish_search()\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_lsl_stream","title":"<code>close_lsl_stream()</code>","text":"<p>Close LSL stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_lsl_stream(self):\n    \"\"\"\n    Close LSL stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_flag = False\n    if hasattr(self, \"_lsl_stream\"):\n        del self._lsl_stream\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.connect_device","title":"<code>connect_device(addr)</code>","text":"<p>Connect to device by address, block until connection is established or failed.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>device address.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if device already connected or connection failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def connect_device(self, addr: str) -&gt; None:\n    \"\"\"\n    Connect to device by address, block until connection is established or failed.\n\n    Args:\n        addr: device address.\n\n    Raises:\n        Exception: if device already connected or connection failed.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected\")\n    try:\n        ret = self.__interface.connect(addr)\n        self.__dev_args.update({\"name\": addr[-2:], \"sock\": ret})\n        self.dev = self.__dev_sock(self.__dev_args)\n        self.__parser.batt_val = self.dev.send_heartbeat()\n        self.__socket_flag = 0\n        self.__info_q.put(True)\n        self.__status = iRecorder.Dev.IDLE_START\n        self.start()\n    except Exception as e:\n        self.__info_q.put(str(e))\n        self.__socket_flag = 2\n        self.__finish_search()\n        raise e\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.find_devs","title":"<code>find_devs(duration=None)</code>","text":"<p>Search for available devices, can only be called once per instance.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[int]</code> <p>Search interval in seconds, blocks for about <code>duration</code> seconds and return found devices.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>Available devices. If <code>duration</code> is set to <code>None</code> it will return <code>None</code> immediately,  devices can later be acquired by calling <code>get_devs()</code> in a loop.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If search thread already running or iRecorder already connected.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n    \"\"\"\n    Search for available devices, can only be called once per instance.\n\n    Args:\n        duration: Search interval in seconds, blocks for about `duration` seconds and return found devices.\n\n    Returns:\n        Available devices. If `duration` is set to `None` it will return `None` immediately, \n            devices can later be acquired by calling `get_devs()` in a loop.\n\n    Raises:\n        Exception: If search thread already running or iRecorder already connected.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected.\")\n    if self.__interface.is_alive():\n        raise Exception(\"Search thread already running.\")\n    self.__interface.start()\n    if duration is None:\n        return\n    start = time.time()\n    while time.time() - start &lt; duration:\n        time.sleep(0.5)\n    self.__finish_search()\n    return self.get_devs()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_available_frequency","title":"<code>get_available_frequency()</code>","text":"<p>Get available sample frequency of device.</p> <p>Returns:</p> Type Description <code>list</code> <p>Available sample frequencies in Hz.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_available_frequency(self) -&gt; list:\n    \"\"\"Get available sample frequency of device.\n\n    Returns:\n        Available sample frequencies in Hz.\n    \"\"\"\n    if self.__dev_args[\"type\"] == \"USB32\":\n        return [500, 1000, 2000]\n    else:\n        return [500]\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_battery_value","title":"<code>get_battery_value()</code>","text":"<p>Query battery level.</p> <p>Returns:</p> Type Description <code>int</code> <p>battery level in percentage, range from <code>0</code> to <code>100</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_battery_value(self) -&gt; int:\n    \"\"\"\n    Query battery level.\n\n    Returns:\n        battery level in percentage, range from `0` to `100`.\n    \"\"\"\n    return self.__parser.batt_val\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_data","title":"<code>get_data(timeout=None)</code>","text":"<p>Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>it blocks at most <code>timeout</code> seconds and return, otherwise it returns until new data is available.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Optional[list]]</code> <p>A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel,  eeg channels can be updatd by <code>update_channels()</code>.</p> Data Unit <ul> <li>eeg: microvolts (\u00b5V)</li> <li>triggerbox: int, from <code>0</code> to <code>255</code></li> </ul> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_data(self, timeout: Optional[float] = None) -&gt; list[Optional[list]]:\n    \"\"\"\n    Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n    Args:\n        timeout: it blocks at most `timeout` seconds and return, otherwise it returns until new data is available.\n\n    Returns:\n        A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel, \n            eeg channels can be updatd by `update_channels()`.\n\n    Data Unit:\n        - eeg: microvolts (\u00b5V)\n        - triggerbox: int, from `0` to `255`\n\n    \"\"\"\n    if self.__socket_flag:\n        self.__raise_sock_error()\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_info","title":"<code>get_dev_info()</code>","text":"<p>Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing device information, which includes: <code>type</code>: hardware type; <code>channel</code>: hardware channel number; <code>AdapterInfo</code>: adapter used for connection; <code>fs</code>: sample frequency in Hz; <code>ch_info</code>: channel dictionary, including channel index and name, can be altered by <code>update_channels()</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_info(self) -&gt; dict:\n    \"\"\"\n    Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n    Returns:\n        A dictionary containing device information, which includes:\n            `type`: hardware type;\n            `channel`: hardware channel number;\n            `AdapterInfo`: adapter used for connection;\n            `fs`: sample frequency in Hz;\n            `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n    \"\"\"\n    from copy import deepcopy\n\n    return deepcopy(self.__dev_args)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_status","title":"<code>get_dev_status()</code>","text":"<p>Get current device status.</p> <p>Returns:</p> Name Type Description <code>SIGNAL</code> <code>str</code> <p>data acquisition mode</p> <code>IMPEDANCE</code> <code>str</code> <p>impedance acquisition mode</p> <code>IDLE</code> <code>str</code> <p>idle mode</p> <code>TERMINATE</code> <code>str</code> <p>device not connected or connection closed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_status(self) -&gt; str:\n    \"\"\"\n    Get current device status.\n\n    Returns:\n        SIGNAL: data acquisition mode\n        IMPEDANCE: impedance acquisition mode\n        IDLE: idle mode\n        TERMINATE: device not connected or connection closed.\n    \"\"\"\n    return self.__status.name\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_devs","title":"<code>get_devs(verbose=False)</code>","text":"<p>Get available devices. This can be called after <code>find_devs(duration = None)</code> in a loop,     each call will only return newly found devices.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>if True, return all available devices information, otherwise only return names for connection, if you don't know what this parameter does, just leave it at its default value.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>Newly found devices.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>adapter not found or not enabled etc.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_devs(self, verbose: bool = False) -&gt; list:\n    \"\"\"\n    Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n        each call will *only* return newly found devices.\n\n    Args:\n        verbose: if True, return all available devices information, otherwise only return names for connection,\n            if you don't know what this parameter does, just leave it at its default value.\n\n    Returns:\n        Newly found devices.\n\n    Raises:\n        Exception: adapter not found or not enabled etc.\n    \"\"\"\n    ret = []\n    while not self.__info_q.empty():\n        info = self.__info_q.get()\n        if isinstance(info, list):\n            ret.append(info if verbose else info[-1])\n        elif isinstance(info, bool):\n            if verbose:\n                ret.append(info)\n        elif isinstance(info, str):\n            raise Exception(info)\n    return ret\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_impedance","title":"<code>get_impedance()</code>","text":"<p>Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.</p> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>A list of channel impedance ranging from <code>0</code> to <code>np.inf</code> if available, otherwise <code>None</code>.</p> Data Unit <ul> <li>impedance: ohm (\u03a9)</li> </ul> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_impedance(self) -&gt; Optional[list]:\n    \"\"\"\n    Acquire channel impedances, return immediatly, impedance update interval is about 2000ms.\n\n    Returns:\n        A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n    Data Unit:\n        - impedance: ohm (\u03a9)\n    \"\"\"\n    if self.__socket_flag:\n        if self.is_alive():\n            self.close_dev()\n        self.__raise_sock_error()\n    return self.__parser.impedance\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_packet_drop_times","title":"<code>get_packet_drop_times()</code>","text":"<p>Retrieve packet drop times. This value accumulates during data transmission and will be reset to <code>0</code> after device status change.</p> <p>Returns:</p> Type Description <code>int</code> <p>accumulated packet drop times.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_packet_drop_times(self) -&gt; int:\n    \"\"\"\n    Retrieve packet drop times.\n    This value accumulates during data transmission and will be reset to `0` after device status change.\n\n    Returns:\n        accumulated packet drop times.\n    \"\"\"\n    return self.__parser._drop_count\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.open_lsl_stream","title":"<code>open_lsl_stream()</code>","text":"<p>Open LSL stream, can be invoked after <code>start_acquisition_data()</code>,     each frame is the same as described in <code>get_data()</code>. </p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def open_lsl_stream(self):\n    \"\"\"\n    Open LSL stream, can be invoked after `start_acquisition_data()`,\n        each frame is the same as described in `get_data()`. \n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_stream\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_stream = lslSender(\n        self.__dev_args[\"ch_info\"],\n        f\"iRe{self.__dev_args['type']}_{self.__dev_args['name']}\",\n        \"EEG\",\n        self.__dev_args[\"fs\"],\n        with_trigger=True,\n    )\n    self.__lsl_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.save_bdf_file","title":"<code>save_bdf_file(filename)</code>","text":"<p>Save data to BDF file, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name to save data, accept absolute or relative path.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or <code>save_bdf_file</code> is invoked and BDF file already created.</p> <code>OSError</code> <p>if BDF file creation failed, this may be caused by invalid file path or permission issue.</p> <code>importError</code> <p>if <code>pyedflib</code> is not installed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def save_bdf_file(self, filename: str):\n    \"\"\"\n    Save data to BDF file, can be invoked after `start_acquisition_data()`.\n\n    Args:\n        filename: file name to save data, accept absolute or relative path.\n\n    Raises:\n        Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n        OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n        importError: if `pyedflib` is not installed.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started\")\n    if hasattr(self, \"_bdf_file\"):\n        raise Exception(\"BDF file already created.\")\n    from ..utils.bdfWrapper import bdfSaver\n\n    if filename[-4:].lower() != \".bdf\":\n        filename += \".bdf\"\n    self._bdf_file = bdfSaver(\n        filename,\n        self.__dev_args[\"ch_info\"],\n        self.__dev_args[\"fs\"],\n        f\"iRecorder{self.__dev_args['type']}\",\n    )\n    self.__bdf_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.send_bdf_marker","title":"<code>send_bdf_marker(marker)</code>","text":"<p>Send marker to BDF file, can be invoked after <code>open_bdf_file()</code>, otherwise it will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>str</code> <p>marker string to write.</p> required Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def send_bdf_marker(self, marker: str):\n    \"\"\"\n    Send marker to BDF file, can be invoked after `open_bdf_file()`, otherwise it will be ignored.\n\n    Args:\n        marker: marker string to write.\n    \"\"\"\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.write_Annotation(marker)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.set_frequency","title":"<code>set_frequency(fs=None)</code>","text":"<p>Update device sample frequency, can only be invoked before <code>connect_device</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>int</code> <p>sample frequency in Hz, if <code>None</code> or fs not in <code>get_available_frequency()</code>,  it will fallback to the lowest available frequency.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if device already connected.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def set_frequency(self, fs: int = None):\n    \"\"\"Update device sample frequency, can only be invoked before `connect_device`.\n\n    Args:\n        fs: sample frequency in Hz, if `None` or fs not in `get_available_frequency()`, \n            it will fallback to the lowest available frequency.\n\n    Raises:\n        Exception: if device already connected.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"Already connected to device\")\n    default = self.get_available_frequency()[0]\n    if fs is None:\n        fs = default\n    if fs not in self.get_available_frequency():\n        print(f\"Invalid sample frequency, fallback to {default}Hz\")\n        fs = default\n    self.__dev_args.update({\"fs\": fs})\n    self.__parser._update_fs(fs)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_data","title":"<code>start_acquisition_data()</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or data acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_data(self):\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n\n    Raises:\n        Exception: if device not connected or data acquisition init failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iRecorder.Dev.SIGNAL:\n        return None\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.SIGNAL_START\n    while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.SIGNAL:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_impedance","title":"<code>start_acquisition_impedance()</code>","text":"<p>Send impedance acquisition command to device, block until data acquisition started or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or impedance acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_impedance(self) -&gt; None:\n    \"\"\"\n    Send impedance acquisition command to device, block until data acquisition started or failed.\n\n    Raises:\n        Exception: if device not connected or impedance acquisition init failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        return None\n    if self.__status == iRecorder.Dev.SIGNAL:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.IMPEDANCE_START\n    while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.IMPEDANCE:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or acquisition stop failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n    Raises:\n        Exception: if device not connected or acquisition stop failed.\n    \"\"\"\n    if self.__status == iRecorder.Dev.TERMINATE:\n        self.__raise_sock_error()\n    self.__status = iRecorder.Dev.IDLE_START\n    while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != iRecorder.Dev.IDLE:\n        self.__raise_sock_error()\n    return None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.update_channels","title":"<code>update_channels(channels=None)</code>","text":"<p>update channel information, valid only when device stopped acquisition. channel number is 0 based.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[dict]</code> <p>channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"}, if <code>None</code> is given, all channels availabel will be used with default values.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if data/impedance acquisition in progress.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def update_channels(self, channels: Optional[dict] = None):\n    \"\"\"\n    update channel information, valid only when device stopped acquisition.\n    channel number is 0 based.\n\n    Args:\n        channels: channel number and name mapping, e.g. {0: \"FPz\", 1: \"Oz\", 2: \"CPz\"},\n            if `None` is given, all channels availabel will be used with default values.\n\n    Raises:\n        Exception: if data/impedance acquisition in progress.\n    \"\"\"\n    if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        raise Exception(\n            \"Device acquisition in progress, please `stop_acquisition` first.\"\n        )\n    if channels is None:\n        from .default_config import getChannels\n\n        channels = getChannels(self.__dev_args[\"channel\"])\n    self.__dev_args.update({\"ch_info\": channels})\n    ch_idx = [i for i in channels.keys()]\n    self.__parser.update_chs(ch_idx)\n</code></pre>"},{"location":"lightStimulator/","title":"Light Stimulator","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class lightStimulator:\n    def __init__(self) -&gt; None:\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        self.wait_time = 0.1\n        self.channels = 6\n        ports = comports()\n        for port in ports:\n            if (\n                port.pid == 0x6001\n                and port.vid == 0x0403\n                and port.serial_number in [\"LIGHTSTIMA\", \"LIGHTSTIM\"]\n            ):\n                self.dev = Serial(port.device, baudrate=115200, timeout=2)\n                self.dev.read_all()\n                break\n        else:\n            raise Exception(\"Light stimulator not found\")\n\n    def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n        \"\"\"\n        Parameters\n        ----------\n        fs : list, default [1,1,1,1,1,1]\n            List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n            If a corresponding frequency is None, 0  or not given, it will be set to off.\n        \"\"\"\n        fss = fs.copy()\n        if len(fss) &lt; self.channels:\n            fss += [0] * (self.channels - len(fss))\n        for i in range(self.channels):\n            fss[i] = self._validate_fs(fss[i])\n        command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n        command = f\"AT+VEP={command}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        print(ret)\n        if b\"SSVEP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def erp_mode(self, fs: float):\n        fs = self._validate_fs(fs)\n        command = f\"AT+ERP={fs:.1f}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        print(ret)\n        if b\"ERP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def _validate_fs(self, fs: float):\n        if not isinstance(fs, (int, float)):\n            if fs is None:\n                fs = 0\n            else:\n                raise Exception(\"Invalid frequency\")\n        if fs &gt; 100 or fs &lt; 0:\n            raise Exception(\"Invalid frequency\")\n        return fs\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"lightStimulator/#eConEXG.lightStimulator.vep_mode","title":"<code>vep_mode(fs=[1, 1, 1, 1, 1, 1])</code>","text":""},{"location":"lightStimulator/#eConEXG.lightStimulator.vep_mode--parameters","title":"Parameters","text":"<p>fs : list, default [1,1,1,1,1,1]     List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.     If a corresponding frequency is None, 0  or not given, it will be set to off.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n    \"\"\"\n    Parameters\n    ----------\n    fs : list, default [1,1,1,1,1,1]\n        List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n        If a corresponding frequency is None, 0  or not given, it will be set to off.\n    \"\"\"\n    fss = fs.copy()\n    if len(fss) &lt; self.channels:\n        fss += [0] * (self.channels - len(fss))\n    for i in range(self.channels):\n        fss[i] = self._validate_fs(fss[i])\n    command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n    command = f\"AT+VEP={command}\\r\\n\".encode()\n    self.dev.write(command)\n    time.sleep(self.wait_time)\n    ret = self.dev.read_all()\n    print(ret)\n    if b\"SSVEP MODE OK\" not in ret:\n        raise Exception(\"Failed to set VEP mode\")\n</code></pre>"},{"location":"triggerBoxWire/","title":"Wired","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWired:\n    def __init__(self, port=None) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        port : str, optional\n            The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            ports = comports()\n        else:\n            ports = [port]\n        for port in ports:\n            if port.pid == 0x5740 and port.vid == 0x0483:\n                self.dev = Serial(port.device, timeout=1)\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n\n    def sendMarker(self, marker: int):\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        self.dev.write(marker.to_bytes())\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWire/#eConEXG.triggerBoxWired.__init__","title":"<code>__init__(port=None)</code>","text":""},{"location":"triggerBoxWire/#eConEXG.triggerBoxWired.__init__--parameters","title":"Parameters","text":"<p>port : str, optional     The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port=None) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    port : str, optional\n        The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        ports = comports()\n    else:\n        ports = [port]\n    for port in ports:\n        if port.pid == 0x5740 and port.vid == 0x0483:\n            self.dev = Serial(port.device, timeout=1)\n            break\n    else:\n        raise Exception(\"Trigger box not found\")\n</code></pre>"},{"location":"triggerBoxWireless/","title":"Wireless","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWireless:\n    def __init__(self, port=None) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n            port : str, optional\n                The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            ports = comports()\n        else:\n            ports = [port]\n        for port in ports:\n            if port.pid == 0x6001 and port.vid == 0x0403:\n                self.dev = Serial(port.device, baudrate=115200, timeout=1)\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n        self.__last_timestamp = time.perf_counter()\n        self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n        time.sleep(0.1)\n\n    def sendMarker(self, marker: int):\n        \"\"\"\n        Send a marker to the trigger box.\n\n        Parameters\n        ----------\n            marker : int\n                range from `1` to `255`, `13` is not available and reserved for internal use.\n        \"\"\"\n        if time.perf_counter() - self.__last_timestamp &lt; 0.045:\n            print(self.__warn)\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        self.dev.write(marker.to_bytes() + b\"\\x55\\x66\\x0d\")\n        self.__last_timestamp = time.perf_counter()\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.__init__","title":"<code>__init__(port=None)</code>","text":""},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.__init__--parameters","title":"Parameters","text":"<pre><code>port : str, optional\n    The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.\n</code></pre> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port=None) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n        port : str, optional\n            The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        ports = comports()\n    else:\n        ports = [port]\n    for port in ports:\n        if port.pid == 0x6001 and port.vid == 0x0403:\n            self.dev = Serial(port.device, baudrate=115200, timeout=1)\n            break\n    else:\n        raise Exception(\"Trigger box not found\")\n    self.__last_timestamp = time.perf_counter()\n    self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n    time.sleep(0.1)\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.sendMarker","title":"<code>sendMarker(marker)</code>","text":"<p>Send a marker to the trigger box.</p>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.sendMarker--parameters","title":"Parameters","text":"<pre><code>marker : int\n    range from `1` to `255`, `13` is not available and reserved for internal use.\n</code></pre> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def sendMarker(self, marker: int):\n    \"\"\"\n    Send a marker to the trigger box.\n\n    Parameters\n    ----------\n        marker : int\n            range from `1` to `255`, `13` is not available and reserved for internal use.\n    \"\"\"\n    if time.perf_counter() - self.__last_timestamp &lt; 0.045:\n        print(self.__warn)\n    if not isinstance(marker, int):\n        marker = int(marker)\n    if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n        raise Exception(\"Invalid marker\")\n    self.dev.write(marker.to_bytes() + b\"\\x55\\x66\\x0d\")\n    self.__last_timestamp = time.perf_counter()\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to eConEXG documentation page.","text":"<p>eConEXG is a Python SDK for hardware made by Niantong Intelligence.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install econexg</code></p> <p>Optional dependencies can be installed via <code>pip install econexg[option1,option2,...]</code></p> <pre><code>Available options:\n    bdf: save to BDF file functionality support.\n    lsl: LSL stream functionality support.\n    usb: iSense USB model support.\n    wifi: iRecorder W32 wifi model support, msvc build tools required.\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Example code can be found in examples.</p>"},{"location":"#platform-support","title":"Platform Support","text":"Hardware Windows macOS Linux iSense USB \u2713 \u2713 \u2713 iRecorder USB \u2713 \u2713 \u2713 iRecorder W8|16 \u2713 \ud800\udd02 \ud800\udd02 iRecorder W32 \u2713 \u2713 \u2713 iFocus \u2713 \u2713 \u2713 TriggerBox \u2713 \u2713 \u2713"},{"location":"#more","title":"More","text":"<ul> <li>Discussion Forum, to discuss the project   on GitHub</li> <li>Issue Tracker, if you run into bugs or have suggestions</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>Here you can find all the released changes to eConEXG.</p>"},{"location":"changelog/#0135","title":"0.1.35","text":"<ul> <li>Fix the bug of missing data when EMG and IMU data are transmitted simultaneously in iFocus and eConAlpha SDK.</li> <li>Update eConAlpha and iFouc SDKs now allow three LSL streams simultaneously running, which are used to transmit EMG data separately, IMU data separately, and both EMG and IMU data simultaneously</li> </ul>"},{"location":"changelog/#0130","title":"0.1.30","text":"<ul> <li>Add iSense USB SDK to the repository</li> </ul>"},{"location":"changelog/#0120","title":"0.1.20","text":"<ul> <li>Fix bug where multiple devices of different type cannot be connected simultaneously</li> <li>Fix bug where LSL stream cannot simultaneously transmit EMG and IMU data</li> <li>Add a new data transmitted policy. data passed directly without through queue, which is more efficient</li> </ul>"},{"location":"changelog/#0118","title":"0.1.18","text":"<p>Release on 2024-10-10</p> <ul> <li>ADD Add <code>create_bdf_file</code> and <code>close_bdf_file</code> to iRecorder and eConAlpha. </li> <li>ADD Add imu support to iRecorder and eConAlpha. </li> </ul>"},{"location":"changelog/#0115","title":"0.1.15","text":"<ul> <li>ADD eConAlpha device SDK</li> </ul>"},{"location":"changelog/#0114","title":"0.1.14","text":"<p>Released on 2024-08-08.</p> <ul> <li>Update pyEDFlib dependency requirement in <code>pyproject.toml</code> from <code>0.1.37</code> to <code>0.1.38</code> to support <code>numpy&gt;=2.0.0</code>.</li> <li>Optimize <code>set_frequency()</code> in <code>iRecorder</code>, now you can set sample rate after device connection.</li> </ul> <ul> <li>Fix <code>iFocus</code> not raise Exception after lost connection with USBadapter.</li> <li>Change <code>with_q</code> argument in <code>iRecorder</code> and <code>iFocus</code> from constructor to <code>start_acquisition_data()</code>.</li> <li>Deprecate <code>save_bdf_file()</code> in <code>iRecorder</code>, use <code>create_bdf_file()</code> instead.</li> </ul>"},{"location":"changelog/#0113","title":"0.1.13","text":"<p>Released on 2024-08-01.</p> <ul> <li>Add <code>get_dev_info()</code> in <code>iFocus</code> class to get device information.</li> <li>Add selectable <code>500Hz</code> eeg and corresponding <code>100Hz</code> IMU sampling rate in <code>iFocus</code> class through <code>set_frequency()</code>.</li> <li>Add <code>with_q = False</code> option in <code>iRecorder</code> and <code>iFocus</code> constructor to drop the necessity of loop calling <code>get_data()</code> in SIGNAL mode.</li> <li>Add <code>__version__</code> field of eConEXG package to check the package version, it can be accessed throught <code>eConEXG.__version__</code>.</li> </ul> <ul> <li>Fix  last valid packet number in <code>iFocus</code> warning message wrongly displayed as a fixed number issue.</li> <li>Change the default data parse length from 0.01 seconds to 10 frames in <code>iRecorder</code> to match hardware settings.</li> <li>Improve the aesthetics of a document interface.</li> </ul>"},{"location":"changelog/#0112","title":"0.1.12","text":"<p>Released on 2024-07-25.</p> <ul> <li>Fix equipment format warning issue on bdf save.</li> <li>Fix Rounding physical_max value of bdf file\uff0cresulting to more accurate data precision.</li> <li>Fix <code>sendMarker()</code> function not working in <code>triggerBox</code> class when python version&lt;3.11.</li> </ul>"},{"location":"changelog/#0111","title":"0.1.11","text":"<p>Released on 2024-07-12.</p> <ul> <li>Update documentation homepage.</li> </ul>"},{"location":"changelog/#0110","title":"0.1.10","text":"<p>Released on 2024-07-08.</p> <ul> <li>Add lsl support for iFocus. </li> <li>Add support for iRecorder 16-channel wired mode.</li> </ul> <ul> <li>Change default timeout of <code>get_data()</code> function in <code>iRecorder</code> from <code>None</code> to <code>0.02</code>.</li> </ul>"},{"location":"changelog/#0109","title":"0.1.09","text":"<p>Released on 2024-06-28.</p> <ul> <li>Add support for iRecorder 8-channel wired mode.</li> </ul>"},{"location":"eConAlpha/","title":"eConAlpha","text":""},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha","title":"<code>eConAlpha</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>class eConAlpha(Thread):\n    class Dev(Enum):\n        SIGNAL = 10\n        SIGNAL_START = 11\n        IDLE = 30\n        IDLE_START = 31\n        TERMINATE = 40\n        TERMINATE_START = 41\n\n    dev_args = {\n        \"type\": \"eConAlpha\",\n        \"fs_emg\": 500,\n        \"fs_imu\": 62.5,\n        \"channel_emg\": {\n            0: \"CH0\",\n            1: \"CH1\",\n            2: \"CH2\",\n            3: \"CH3\",\n            4: \"CH4\",\n            5: \"CH5\",\n            6: \"CH6\",\n            7: \"CH7\",\n        },\n        \"channel_imu\": {\n            0: \"ACC_X\",\n            1: \"ACC_Y\",\n            2: \"ACC_Z\",\n            3: \"GRY_X\",\n            4: \"GRY_Y\",\n            5: \"GRY_Z\",\n        },\n        \"AdapterInfo\": \"Serial Port\",\n        \"samples_per_packet\": 8,  # Number of samples per electrode to be sent in one packet\n    }\n\n    def __init__(self, port: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Args:\n            port: if not given, connect to the first available device.\n        \"\"\"\n        super().__init__(daemon=True)\n        self.__status = eConAlpha.Dev.TERMINATE\n        if port is None:\n            port = eConAlpha.find_devs()[0]\n        self.__save_data = Queue()\n        self.__parser = Parser()\n        self.dev_args = deepcopy(eConAlpha.dev_args)\n        self.dev = sock(port, self.__parser.threshold)\n        self.set_frequency()\n        self.__with_q = True\n        self.__socket_flag = \"Device not connected, please connect first.\"\n        self.__bdf_flag = False\n        try:\n            self.dev.connect_socket()\n        except Exception as e:\n            try:\n                self.dev.close_socket()\n            finally:\n                raise e\n        self.__status = eConAlpha.Dev.IDLE_START\n        self.__socket_flag = None\n        self.__lsl_imu_flag = False\n        self.__lsl_emg_flag = False\n        self.__lsl_emg_imu_flag = False\n        self._bdf_file = None\n        self.__enable_imu = False\n        self.dev_args[\"name\"] = port\n        self.start()\n\n    def set_frequency(self, fs_emg: Optional[int] = None):\n        \"\"\"\n        Change the sampling frequency of eConAlpha.\n\n        Args:\n            fs_emg: sampling frequency of emg data, should be 250, 500, 1000 or 2000.\n                fs_imu will be automatically set to 1/8 of fs_emg.\n\n        Raises:\n            ValueError: if fs_emg is not valid.\n            NotImplementedError: device firmware too old, not supporting 500Hz.\n        \"\"\"\n        if self.__status == eConAlpha.Dev.SIGNAL:\n            raise Exception(\"Data acquisition already started, please stop first.\")\n        if fs_emg is None:\n            fs_emg = self.dev_args[\"fs_emg\"]\n        if fs_emg not in [250, 500, 1000, 2000]:\n            raise ValueError(\"fs_emg should be 250, 500, 1000, or 2000\")\n        self.dev_args[\"fs_emg\"] = fs_emg\n        fs_imu = fs_emg / 8\n        self.dev_args[\"fs_imu\"] = fs_imu\n        if hasattr(self, \"dev\"):\n            self.dev.set_frequency(fs_emg)\n\n    def get_dev_info(self) -&gt; dict:\n        \"\"\"\n        Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n        Returns:\n            A dictionary containing device information, which includes:\n                `type`: hardware type;\n                `channel_emg`: channel dictionary, including EMG channel index and name;\n                `channel_imu`: channel dictionary, including IMU channel index and name;\n                `AdapterInfo`: adapter used for connection;\n                `fs_emg`: sample frequency of EMG in Hz;\n                `fs_imu`: sample frequency of IMU in Hz;\n        \"\"\"\n        return deepcopy(self.dev_args)\n\n    @staticmethod\n    def find_devs() -&gt; list:\n        \"\"\"\n        Find available eConAlpha devices.\n\n        Returns:\n            available device ports.\n\n        Raises:\n            Exception: if no eConAlpha device found.\n        \"\"\"\n        return sock.find_devs()\n\n    def get_data(\n        self, timeout: Optional[float] = 0.02\n    ) -&gt; Optional[list[Optional[list]]]:\n        \"\"\"\n        Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n        Args:\n            timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n        Returns:\n            A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below:\n                [[`emg_ch0_0,...,emg_ch8_0`],..., [`emg_ch0_7,...,emg_ch8_7`], [`acc_x`, `acc_y`, `acc_z`,`gry_x`,`gry_y`,`gry_z`]],\n                    in which number `0~4` after `_` indicates the time order of channel data.\n\n        Raises:\n            Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n        Data Unit:\n            - emg: \u00b5V\n            - acc: mg\n            - gry: bps\n        \"\"\"\n        self.__check_dev_status()\n        if not self.__with_q:\n            return\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def start_acquisition_data(self, with_q: bool = True) -&gt; None:\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n\n        Args:\n            with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n                if False, new data will not be directly available and can only be accessed through lsl stream.\n\n        \"\"\"\n        self.__check_dev_status()\n        self.__with_q = with_q\n        if self.__status == eConAlpha.Dev.SIGNAL:\n            return\n        self.__status = eConAlpha.Dev.SIGNAL_START\n        while self.__status not in [eConAlpha.Dev.SIGNAL, eConAlpha.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n        \"\"\"\n        self.__check_dev_status()\n        self.__status = eConAlpha.Dev.IDLE_START\n        while self.__status not in [eConAlpha.Dev.IDLE, eConAlpha.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def open_lsl_emg(self):\n        \"\"\"\n        Open LSL EMG stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != eConAlpha.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_emg\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        # Create an expanded channel dictionary for LSL stream creation,\n        # replicating each electrode label 'samples_per_packet' times.\n        expanded_channels = {}\n        current_key = 0\n        for label in self.dev_args[\"channel_emg\"].values():\n            for _ in range(self.dev_args[\"samples_per_packet\"]):\n                expanded_channels[current_key] = label\n                current_key += 1\n\n        # Use the expanded channel dictionary for initializing the LSL stream\n        self._lsl_emg = lslSender(\n            expanded_channels,  # Expanded channels reflecting samples_per_packet\n            f\"{self.dev_args['type']}EMG{self.dev_args['name'][-2:]}\",\n            \"EMG\",\n            self.dev_args[\"fs_emg\"],\n            with_trigger=False,\n        )\n        self.__lsl_emg_flag = True\n\n    def close_lsl_emg(self):\n        \"\"\"\n        Close LSL EMG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_emg_flag = False\n        if hasattr(self, \"_lsl_emg\"):\n            del self._lsl_emg\n\n    def open_lsl_imu(self):\n        \"\"\"\n        Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != eConAlpha.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_imu\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_imu = lslSender(\n            self.dev_args[\"channel_imu\"],\n            f\"{self.dev_args['type']}IMU{self.dev_args['name'][-2:]}\",\n            \"IMU\",\n            self.dev_args[\"fs_imu\"],\n            unit=\"degree\",\n            with_trigger=False,\n        )\n        self.__lsl_imu_flag = True\n\n    def close_lsl_imu(self):\n        \"\"\"\n        Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_imu_flag = False\n        if hasattr(self, \"_lsl_imu\"):\n            del self._lsl_imu\n\n    def open_lsl_emg_imu(self):\n        \"\"\"\n        Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != eConAlpha.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_emg_imu\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        key = 0\n        elctds = {}\n        # Expand EMG channels: repeat each EMG electrode label 'samples_per_packet' times.\n        for v in self.dev_args[\"channel_emg\"].values():\n            for _ in range(self.dev_args[\"samples_per_packet\"]):\n                elctds[key] = v\n                key += 1\n        # Add IMU channels as they are (no expansion)\n        for v in self.dev_args[\"channel_imu\"].values():\n            elctds[key] = v\n            key += 1\n\n        self._lsl_emg_imu = lslSender(\n            elctds,\n            f\"{self.dev_args['type']}EMG-IMU{self.dev_args['name'][-2:]}\",\n            \"EMG-IMU\",\n            self.dev_args[\"fs_emg\"] + self.dev_args[\"fs_imu\"],\n            unit=\"degree\",\n            with_trigger=False,\n        )\n        # Note: This combined LSL stream now reflects the expanded EMG channels\n        # and original IMU channels, ensuring the packet structure is maintained.\n        self.__lsl_emg_imu_flag = True\n\n    def close_lsl_emg_imu(self):\n        \"\"\"\n        Close LSL EMG and IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_emg_imu_flag = False\n        if hasattr(self, \"_lsl_emg_imu\"):\n            del self._lsl_emg_imu\n\n    def setIMUFlag(self, check):\n        self.__enable_imu = check\n\n    def create_bdf_file(self, filename: str):\n        \"\"\"\n        Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n        Args:\n            filename: file name to save data, accept absolute or relative path.\n\n        Raises:\n            Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n            OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n            importError: if `pyedflib` is not installed.\n        \"\"\"\n        if self.__status != eConAlpha.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started\")\n        if self._bdf_file is not None:\n            raise Exception(\"BDF file already created.\")\n        from ..utils.bdfWrapper import bdfSaverEMG, bdfSaverEMGIMU\n\n        if filename[-4:].lower() != \".bdf\":\n            filename += \".bdf\"\n        if self.__enable_imu:\n            self._bdf_file = bdfSaverEMGIMU(\n                filename,\n                self.dev_args[\"channel_emg\"],\n                self.dev_args[\"fs_emg\"],\n                self.dev_args[\"channel_imu\"],\n                self.dev_args[\"fs_imu\"],\n                self.dev_args[\"type\"],\n            )\n        else:\n            self._bdf_file = bdfSaverEMG(\n                filename,\n                self.dev_args[\"channel_emg\"],\n                self.dev_args[\"fs_emg\"],\n                self.dev_args[\"type\"],\n            )\n        self.__bdf_flag = True\n\n    def close_bdf_file(self):\n        \"\"\"\n        Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n        \"\"\"\n        self.__bdf_flag = False\n        if self._bdf_file is not None:\n            self._bdf_file.close_bdf()\n            self._bdf_file = None\n\n    def send_bdf_marker(self, marker: str):\n        \"\"\"\n        Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n        Args:\n            marker: marker string to write.\n        \"\"\"\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.write_Annotation(marker)\n\n    def shock_band(self):\n        \"\"\"\n        Send a command to vibrate the arm band\n        \"\"\"\n        self.dev.shock_band()\n\n    def close_dev(self):\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != eConAlpha.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = eConAlpha.Dev.TERMINATE_START\n            while self.__status != eConAlpha.Dev.TERMINATE:\n                time.sleep(0.1)\n        if self.is_alive():\n            self.join()\n\n    def __recv_data(self):\n        try:\n            self.dev.start_data()\n            self.__status = eConAlpha.Dev.SIGNAL\n        except Exception:\n            self.__socket_flag = \"SIGNAL mode initialization failed.\"\n            self.__status = eConAlpha.Dev.TERMINATE_START\n\n        while self.__status in [eConAlpha.Dev.SIGNAL]:\n            try:\n                data = self.dev.recv_socket()\n                if not data:\n                    raise Exception(\"Data transmission timeout.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    if self.__with_q:\n                        self.__save_data.put(ret)\n                    if self.__bdf_flag:\n                        self._bdf_file.write_chunk(ret)\n                    if self.__lsl_emg_flag:\n                        self._lsl_emg.push_chunk(\n                            [frame for frames in ret for frame in frames[:-1]]\n                        )\n                    if self.__lsl_imu_flag:\n                        self._lsl_imu.push_chunk([frame[-1] for frame in ret])\n                    if self.__lsl_emg_imu_flag:\n                        self._lsl_emg_imu.push_chunk(\n                            [frame for frames in ret for frame in frames[:-1]]\n                            + [frame[-1] for frame in ret]\n                        )\n            except Exception as e:\n                print(e)\n                self.__socket_flag = \"Data transmission timeout.\"\n                self.__status = eConAlpha.Dev.TERMINATE_START\n\n        # clear buffer\n        self.close_lsl_emg()\n        self.close_lsl_imu()\n        self.close_lsl_emg_imu()\n        self.close_bdf_file()\n        # self.dev.stop_recv()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != eConAlpha.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == eConAlpha.Dev.IDLE_START:\n                    self.__socket_flag = \"Connection lost.\"\n                self.__status = eConAlpha.Dev.TERMINATE_START\n\n    def run(self):\n        while self.__status != eConAlpha.Dev.TERMINATE_START:\n            if self.__status == eConAlpha.Dev.SIGNAL_START:\n                self.__recv_data()\n            elif self.__status == eConAlpha.Dev.IDLE_START:\n                self.__status = eConAlpha.Dev.IDLE\n                while self.__status == eConAlpha.Dev.IDLE:\n                    time.sleep(0.1)\n            else:\n                self.__socket_flag = f\"Unknown status: {self.__status.name}\"\n                break\n        try:\n            self.dev.close_socket()\n        finally:\n            self.__status = eConAlpha.Dev.TERMINATE\n\n    def __check_dev_status(self):\n        if self.__socket_flag is None:\n            return\n        if self.is_alive():\n            self.close_dev()\n        raise Exception(str(self.__socket_flag))\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>if not given, connect to the first available device.</p> <code>None</code> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def __init__(self, port: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Args:\n        port: if not given, connect to the first available device.\n    \"\"\"\n    super().__init__(daemon=True)\n    self.__status = eConAlpha.Dev.TERMINATE\n    if port is None:\n        port = eConAlpha.find_devs()[0]\n    self.__save_data = Queue()\n    self.__parser = Parser()\n    self.dev_args = deepcopy(eConAlpha.dev_args)\n    self.dev = sock(port, self.__parser.threshold)\n    self.set_frequency()\n    self.__with_q = True\n    self.__socket_flag = \"Device not connected, please connect first.\"\n    self.__bdf_flag = False\n    try:\n        self.dev.connect_socket()\n    except Exception as e:\n        try:\n            self.dev.close_socket()\n        finally:\n            raise e\n    self.__status = eConAlpha.Dev.IDLE_START\n    self.__socket_flag = None\n    self.__lsl_imu_flag = False\n    self.__lsl_emg_flag = False\n    self.__lsl_emg_imu_flag = False\n    self._bdf_file = None\n    self.__enable_imu = False\n    self.dev_args[\"name\"] = port\n    self.start()\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.close_bdf_file","title":"<code>close_bdf_file()</code>","text":"<p>Close and save BDF file manually, invoked automatically after <code>stop_acquisition()</code> or <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def close_bdf_file(self):\n    \"\"\"\n    Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n    \"\"\"\n    self.__bdf_flag = False\n    if self._bdf_file is not None:\n        self._bdf_file.close_bdf()\n        self._bdf_file = None\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def close_dev(self):\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != eConAlpha.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = eConAlpha.Dev.TERMINATE_START\n        while self.__status != eConAlpha.Dev.TERMINATE:\n            time.sleep(0.1)\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.close_lsl_emg","title":"<code>close_lsl_emg()</code>","text":"<p>Close LSL EMG stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def close_lsl_emg(self):\n    \"\"\"\n    Close LSL EMG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_emg_flag = False\n    if hasattr(self, \"_lsl_emg\"):\n        del self._lsl_emg\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.close_lsl_emg_imu","title":"<code>close_lsl_emg_imu()</code>","text":"<p>Close LSL EMG and IMU stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def close_lsl_emg_imu(self):\n    \"\"\"\n    Close LSL EMG and IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_emg_imu_flag = False\n    if hasattr(self, \"_lsl_emg_imu\"):\n        del self._lsl_emg_imu\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.close_lsl_imu","title":"<code>close_lsl_imu()</code>","text":"<p>Close LSL IMU stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def close_lsl_imu(self):\n    \"\"\"\n    Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_imu_flag = False\n    if hasattr(self, \"_lsl_imu\"):\n        del self._lsl_imu\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.create_bdf_file","title":"<code>create_bdf_file(filename)</code>","text":"<p>Create a BDF file and save data to it, invoke it after <code>start_acquisition_data()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name to save data, accept absolute or relative path.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or <code>save_bdf_file</code> is invoked and BDF file already created.</p> <code>OSError</code> <p>if BDF file creation failed, this may be caused by invalid file path or permission issue.</p> <code>importError</code> <p>if <code>pyedflib</code> is not installed.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def create_bdf_file(self, filename: str):\n    \"\"\"\n    Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n    Args:\n        filename: file name to save data, accept absolute or relative path.\n\n    Raises:\n        Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n        OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n        importError: if `pyedflib` is not installed.\n    \"\"\"\n    if self.__status != eConAlpha.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started\")\n    if self._bdf_file is not None:\n        raise Exception(\"BDF file already created.\")\n    from ..utils.bdfWrapper import bdfSaverEMG, bdfSaverEMGIMU\n\n    if filename[-4:].lower() != \".bdf\":\n        filename += \".bdf\"\n    if self.__enable_imu:\n        self._bdf_file = bdfSaverEMGIMU(\n            filename,\n            self.dev_args[\"channel_emg\"],\n            self.dev_args[\"fs_emg\"],\n            self.dev_args[\"channel_imu\"],\n            self.dev_args[\"fs_imu\"],\n            self.dev_args[\"type\"],\n        )\n    else:\n        self._bdf_file = bdfSaverEMG(\n            filename,\n            self.dev_args[\"channel_emg\"],\n            self.dev_args[\"fs_emg\"],\n            self.dev_args[\"type\"],\n        )\n    self.__bdf_flag = True\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.find_devs","title":"<code>find_devs()</code>  <code>staticmethod</code>","text":"<p>Find available eConAlpha devices.</p> <p>Returns:</p> Type Description <code>list</code> <p>available device ports.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if no eConAlpha device found.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>@staticmethod\ndef find_devs() -&gt; list:\n    \"\"\"\n    Find available eConAlpha devices.\n\n    Returns:\n        available device ports.\n\n    Raises:\n        Exception: if no eConAlpha device found.\n    \"\"\"\n    return sock.find_devs()\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.get_data","title":"<code>get_data(timeout=0.02)</code>","text":"<p>Acquire all available data, make sure this function is called in a loop when <code>with_q</code> is set to <code>True</code> in<code>start_acquisition_data()</code></p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Non-negative value, blocks at most 'timeout' seconds and return, if set to <code>None</code>, blocks until new data available.</p> <code>0.02</code> <p>Returns:</p> Type Description <code>Optional[list[Optional[list]]]</code> <p>A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below: [[<code>emg_ch0_0,...,emg_ch8_0</code>],..., [<code>emg_ch0_7,...,emg_ch8_7</code>], [<code>acc_x</code>, <code>acc_y</code>, <code>acc_z</code>,<code>gry_x</code>,<code>gry_y</code>,<code>gry_z</code>]],     in which number <code>0~4</code> after <code>_</code> indicates the time order of channel data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected, connection failed, data transmission timeout/init failed, or unknown error.</p> Data Unit <ul> <li>emg: \u00b5V</li> <li>acc: mg</li> <li>gry: bps</li> </ul> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def get_data(\n    self, timeout: Optional[float] = 0.02\n) -&gt; Optional[list[Optional[list]]]:\n    \"\"\"\n    Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n    Args:\n        timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n    Returns:\n        A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below:\n            [[`emg_ch0_0,...,emg_ch8_0`],..., [`emg_ch0_7,...,emg_ch8_7`], [`acc_x`, `acc_y`, `acc_z`,`gry_x`,`gry_y`,`gry_z`]],\n                in which number `0~4` after `_` indicates the time order of channel data.\n\n    Raises:\n        Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n    Data Unit:\n        - emg: \u00b5V\n        - acc: mg\n        - gry: bps\n    \"\"\"\n    self.__check_dev_status()\n    if not self.__with_q:\n        return\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.get_dev_info","title":"<code>get_dev_info()</code>","text":"<p>Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing device information, which includes: <code>type</code>: hardware type; <code>channel_emg</code>: channel dictionary, including EMG channel index and name; <code>channel_imu</code>: channel dictionary, including IMU channel index and name; <code>AdapterInfo</code>: adapter used for connection; <code>fs_emg</code>: sample frequency of EMG in Hz; <code>fs_imu</code>: sample frequency of IMU in Hz;</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def get_dev_info(self) -&gt; dict:\n    \"\"\"\n    Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n    Returns:\n        A dictionary containing device information, which includes:\n            `type`: hardware type;\n            `channel_emg`: channel dictionary, including EMG channel index and name;\n            `channel_imu`: channel dictionary, including IMU channel index and name;\n            `AdapterInfo`: adapter used for connection;\n            `fs_emg`: sample frequency of EMG in Hz;\n            `fs_imu`: sample frequency of IMU in Hz;\n    \"\"\"\n    return deepcopy(self.dev_args)\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.open_lsl_emg","title":"<code>open_lsl_emg()</code>","text":"<p>Open LSL EMG stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def open_lsl_emg(self):\n    \"\"\"\n    Open LSL EMG stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != eConAlpha.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_emg\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    # Create an expanded channel dictionary for LSL stream creation,\n    # replicating each electrode label 'samples_per_packet' times.\n    expanded_channels = {}\n    current_key = 0\n    for label in self.dev_args[\"channel_emg\"].values():\n        for _ in range(self.dev_args[\"samples_per_packet\"]):\n            expanded_channels[current_key] = label\n            current_key += 1\n\n    # Use the expanded channel dictionary for initializing the LSL stream\n    self._lsl_emg = lslSender(\n        expanded_channels,  # Expanded channels reflecting samples_per_packet\n        f\"{self.dev_args['type']}EMG{self.dev_args['name'][-2:]}\",\n        \"EMG\",\n        self.dev_args[\"fs_emg\"],\n        with_trigger=False,\n    )\n    self.__lsl_emg_flag = True\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.open_lsl_emg_imu","title":"<code>open_lsl_emg_imu()</code>","text":"<p>Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def open_lsl_emg_imu(self):\n    \"\"\"\n    Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != eConAlpha.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_emg_imu\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    key = 0\n    elctds = {}\n    # Expand EMG channels: repeat each EMG electrode label 'samples_per_packet' times.\n    for v in self.dev_args[\"channel_emg\"].values():\n        for _ in range(self.dev_args[\"samples_per_packet\"]):\n            elctds[key] = v\n            key += 1\n    # Add IMU channels as they are (no expansion)\n    for v in self.dev_args[\"channel_imu\"].values():\n        elctds[key] = v\n        key += 1\n\n    self._lsl_emg_imu = lslSender(\n        elctds,\n        f\"{self.dev_args['type']}EMG-IMU{self.dev_args['name'][-2:]}\",\n        \"EMG-IMU\",\n        self.dev_args[\"fs_emg\"] + self.dev_args[\"fs_imu\"],\n        unit=\"degree\",\n        with_trigger=False,\n    )\n    # Note: This combined LSL stream now reflects the expanded EMG channels\n    # and original IMU channels, ensuring the packet structure is maintained.\n    self.__lsl_emg_imu_flag = True\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.open_lsl_imu","title":"<code>open_lsl_imu()</code>","text":"<p>Open LSL IMU stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def open_lsl_imu(self):\n    \"\"\"\n    Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != eConAlpha.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_imu\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_imu = lslSender(\n        self.dev_args[\"channel_imu\"],\n        f\"{self.dev_args['type']}IMU{self.dev_args['name'][-2:]}\",\n        \"IMU\",\n        self.dev_args[\"fs_imu\"],\n        unit=\"degree\",\n        with_trigger=False,\n    )\n    self.__lsl_imu_flag = True\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.send_bdf_marker","title":"<code>send_bdf_marker(marker)</code>","text":"<p>Send marker to BDF file, can be invoked after <code>create_bdf_file()</code>, otherwise it will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>str</code> <p>marker string to write.</p> required Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def send_bdf_marker(self, marker: str):\n    \"\"\"\n    Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n    Args:\n        marker: marker string to write.\n    \"\"\"\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.write_Annotation(marker)\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.set_frequency","title":"<code>set_frequency(fs_emg=None)</code>","text":"<p>Change the sampling frequency of eConAlpha.</p> <p>Parameters:</p> Name Type Description Default <code>fs_emg</code> <code>Optional[int]</code> <p>sampling frequency of emg data, should be 250, 500, 1000 or 2000. fs_imu will be automatically set to 1/8 of fs_emg.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if fs_emg is not valid.</p> <code>NotImplementedError</code> <p>device firmware too old, not supporting 500Hz.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def set_frequency(self, fs_emg: Optional[int] = None):\n    \"\"\"\n    Change the sampling frequency of eConAlpha.\n\n    Args:\n        fs_emg: sampling frequency of emg data, should be 250, 500, 1000 or 2000.\n            fs_imu will be automatically set to 1/8 of fs_emg.\n\n    Raises:\n        ValueError: if fs_emg is not valid.\n        NotImplementedError: device firmware too old, not supporting 500Hz.\n    \"\"\"\n    if self.__status == eConAlpha.Dev.SIGNAL:\n        raise Exception(\"Data acquisition already started, please stop first.\")\n    if fs_emg is None:\n        fs_emg = self.dev_args[\"fs_emg\"]\n    if fs_emg not in [250, 500, 1000, 2000]:\n        raise ValueError(\"fs_emg should be 250, 500, 1000, or 2000\")\n    self.dev_args[\"fs_emg\"] = fs_emg\n    fs_imu = fs_emg / 8\n    self.dev_args[\"fs_imu\"] = fs_imu\n    if hasattr(self, \"dev\"):\n        self.dev.set_frequency(fs_emg)\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.shock_band","title":"<code>shock_band()</code>","text":"<p>Send a command to vibrate the arm band</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def shock_band(self):\n    \"\"\"\n    Send a command to vibrate the arm band\n    \"\"\"\n    self.dev.shock_band()\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.start_acquisition_data","title":"<code>start_acquisition_data(with_q=True)</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> <p>Parameters:</p> Name Type Description Default <code>with_q</code> <code>bool</code> <p>if True, signal data will be stored in a queue and should be acquired by calling <code>get_data()</code> in a loop in case data queue is full. if False, new data will not be directly available and can only be accessed through lsl stream.</p> <code>True</code> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def start_acquisition_data(self, with_q: bool = True) -&gt; None:\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n\n    Args:\n        with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n            if False, new data will not be directly available and can only be accessed through lsl stream.\n\n    \"\"\"\n    self.__check_dev_status()\n    self.__with_q = with_q\n    if self.__status == eConAlpha.Dev.SIGNAL:\n        return\n    self.__status = eConAlpha.Dev.SIGNAL_START\n    while self.__status not in [eConAlpha.Dev.SIGNAL, eConAlpha.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"eConAlpha/#eConEXG.eConAlpha.eConAlpha.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> Source code in <code>src\\eConEXG\\eConAlpha\\data_reader.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n    \"\"\"\n    self.__check_dev_status()\n    self.__status = eConAlpha.Dev.IDLE_START\n    while self.__status not in [eConAlpha.Dev.IDLE, eConAlpha.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iFocus/","title":"iFocus","text":""},{"location":"iFocus/#eConEXG.iFocus.iFocus","title":"<code>iFocus</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>class iFocus(Thread):\n    class Dev(Enum):\n        SIGNAL = 10\n        SIGNAL_START = 11\n        IDLE = 30\n        IDLE_START = 31\n        TERMINATE = 40\n        TERMINATE_START = 41\n\n    dev_args = {\n        \"type\": \"iFocus\",\n        \"fs_emg\": 250,\n        \"fs_imu\": 50,\n        \"channel_emg\": {0: \"CH0\"},\n        \"channel_imu\": {0: \"X\", 1: \"Y\", 2: \"Z\"},\n        \"AdapterInfo\": \"Serial Port\",\n        \"samples_per_packet\": 5,  # Number of samples per electrode to be sent in one packet\n    }\n\n    def __init__(self, port: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Args:\n            port: if not given, connect to the first available device.\n        \"\"\"\n        super().__init__(daemon=True)\n        self.__status = iFocus.Dev.TERMINATE\n        if port is None:\n            port = iFocus.find_devs()[0]\n        self.__save_data = Queue()\n        self.__parser = Parser()\n        self.dev_args = deepcopy(iFocus.dev_args)\n        self.dev = sock(port)\n        self.set_frequency()\n        self.__with_q = True\n        self.__socket_flag = \"Device not connected, please connect first.\"\n        self.__bdf_flag = False\n        try:\n            self.dev.connect_socket()\n        except Exception as e:\n            try:\n                self.dev.close_socket()\n            finally:\n                raise e\n        self.__status = iFocus.Dev.IDLE_START\n        self.__socket_flag = None\n        self._lsl_emg = None\n        self._lsl_imu = None\n        self._lsl_emg_imu = None\n        self.__lsl_imu_flag = False\n        self.__lsl_emg_flag = False\n        self.__lsl_emg_imu_flag = False\n        self._bdf_file = None\n        self.__enable_imu = False\n        self.dev_args[\"name\"] = port\n        self.start()\n\n    def set_frequency(self, fs_emg: int = None):\n        \"\"\"\n        Change the sampling frequency of iFocus.\n\n        Args:\n            fs_emg: sampling frequency of emg data, should be 250 or 500,\n                fs_imu will be automatically set to 1/5 of fs_emg.\n\n        Raises:\n            ValueError: if fs_emg is not 250 or 500.\n            NotImplementedError: device firmware too old, not supporting 500Hz.\n        \"\"\"\n        if self.__status == iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition already started, please stop first.\")\n        if fs_emg is None:\n            fs_emg = self.dev_args[\"fs_emg\"]\n        if fs_emg not in [250, 500]:\n            raise ValueError(\"fs_emg should be 250 or 500\")\n        self.dev_args[\"fs_emg\"] = fs_emg\n        fs_imu = fs_emg // 5\n        self.dev_args[\"fs_imu\"] = fs_imu\n        if hasattr(self, \"dev\"):\n            self.dev.set_frequency(fs_emg)\n\n    def get_dev_info(self) -&gt; dict:\n        \"\"\"\n        Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n        Returns:\n            A dictionary containing device information, which includes:\n                `type`: hardware type;\n                `channel_emg`: channel dictionary, including EMG channel index and name;\n                `channel_imu`: channel dictionary, including IMU channel index and name;\n                `AdapterInfo`: adapter used for connection;\n                `fs_emg`: sample frequency of EMG in Hz;\n                `fs_imu`: sample frequency of IMU in Hz;\n        \"\"\"\n        return deepcopy(self.dev_args)\n\n    @staticmethod\n    def find_devs() -&gt; list:\n        \"\"\"\n        Find available iFocus devices.\n\n        Returns:\n            available device ports.\n\n        Raises:\n            Exception: if no iFocus device found.\n        \"\"\"\n        return sock._find_devs()\n\n    def get_data(\n        self, timeout: Optional[float] = 0.02\n    ) -&gt; Optional[list[Optional[list]]]:\n        \"\"\"\n        Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n        Args:\n            timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n        Returns:\n            A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below:\n                [[`emg_0`], [`emg_1`], [`emg_2`], [`emg_3`], [`emg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                    in which number `0~4` after `_` indicates the time order of channel data.\n\n        Raises:\n            Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n        Data Unit:\n            - emg: \u00b5V\n            - imu: degree(\u00b0)\n        \"\"\"\n        self.__check_dev_status()\n        if not self.__with_q:\n            return\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def start_acquisition_data(self, with_q: bool = True) -&gt; None:\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n\n        Args:\n            with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n                if False, new data will not be directly available and can only be acquired through lsl stream.\n\n        \"\"\"\n        self.__check_dev_status()\n        self.__with_q = with_q\n        if self.__status == iFocus.Dev.SIGNAL:\n            return\n        self.__status = iFocus.Dev.SIGNAL_START\n        while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n        \"\"\"\n        self.__check_dev_status()\n        self.__status = iFocus.Dev.IDLE_START\n        while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def open_lsl_emg(self):\n        \"\"\"\n        Open LSL EMG stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            ImportError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if self._lsl_emg is not None:\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        # Create an expanded channel dictionary for LSL stream creation,\n        # replicating each electrode label 'samples_per_packet' times.\n        expanded_channels = {}\n        current_key = 0\n        for label in self.dev_args[\"channel_emg\"].values():\n            for _ in range(self.dev_args[\"samples_per_packet\"]):\n                expanded_channels[current_key] = label\n                current_key += 1\n\n        # Use the expanded channel dictionary for initializing the LSL stream.\n        self._lsl_emg = lslSender(\n            expanded_channels,  # Expanded channels reflecting samples_per_packet.\n            f\"{self.dev_args['type']}EMG{self.dev_args['name'][-2:]}\",\n            \"EMG\",\n            self.dev_args[\"fs_emg\"],\n            with_trigger=False,\n        )\n        self.__lsl_emg_flag = True\n\n    def close_lsl_emg(self):\n        \"\"\"\n        Close LSL EMG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_emg_flag = False\n        if self._lsl_emg is not None:\n            self._lsl_emg = None\n\n    def open_lsl_imu(self):\n        \"\"\"\n        Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if self._lsl_imu is not None:\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_imu = lslSender(\n            self.dev_args[\"channel_imu\"],\n            f\"{self.dev_args['type']}IMU{self.dev_args['name'][-2:]}\",\n            \"IMU\",\n            self.dev_args[\"fs_imu\"],\n            unit=\"degree\",\n            with_trigger=False,\n        )\n        self.__lsl_imu_flag = True\n\n    def close_lsl_imu(self):\n        \"\"\"\n        Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_imu_flag = False\n        if self._lsl_imu is not None:\n            self._lsl_imu = None\n\n    def open_lsl_emg_imu(self):\n        \"\"\"\n        Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after `start_acquisition_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            ImportError: if `pylsl` is not installed or liblsl not installed for unix like system.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if self._lsl_emg_imu is not None:\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        key = 0\n        elctds = {}\n        # Expand EMG channels: repeat each EMG electrode label 'samples_per_packet' times.\n        for v in self.dev_args[\"channel_emg\"].values():\n            for _ in range(self.dev_args[\"samples_per_packet\"]):\n                elctds[key] = v\n                key += 1\n        # Add IMU channels as they are (no expansion)\n        for v in self.dev_args[\"channel_imu\"].values():\n            elctds[key] = v\n            key += 1\n\n        self._lsl_emg_imu = lslSender(\n            elctds,\n            f\"{self.dev_args['type']}EMG-IMU{self.dev_args['name'][-2:]}\",\n            \"EMG-IMU\",\n            self.dev_args[\"fs_emg\"] + self.dev_args[\"fs_imu\"],\n            unit=\"degree\",\n            with_trigger=False,\n        )\n        # Note: This combined LSL stream now reflects the expanded EMG channels\n        # and original IMU channels, ensuring the packet structure is maintained.\n        self.__lsl_emg_imu_flag = True\n\n    def close_lsl_emg_imu(self):\n        \"\"\"\n        Close LSL EMG and IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n        \"\"\"\n        self.__lsl_emg_imu_flag = False\n        if self._lsl_emg_imu is not None:\n            self._lsl_emg_imu = None\n\n    def setIMUFlag(self, check):\n        self.__enable_imu = check\n\n    def create_bdf_file(self, filename: str):\n        \"\"\"\n        Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n        Args:\n            filename: file name to save data, accept absolute or relative path.\n\n        Raises:\n            Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n            OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n            importError: if `pyedflib` is not installed.\n        \"\"\"\n        if self.__status != iFocus.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started\")\n        if self._bdf_file is not None:\n            raise Exception(\"BDF file already created.\")\n        from ..utils.bdfWrapper import bdfSaverEMG, bdfSaverEMGIMU\n\n        if filename[-4:].lower() != \".bdf\":\n            filename += \".bdf\"\n        if self.__enable_imu:\n            self._bdf_file = bdfSaverEMGIMU(\n                filename,\n                self.dev_args[\"channel_emg\"],\n                self.dev_args[\"fs_emg\"],\n                self.dev_args[\"channel_imu\"],\n                self.dev_args[\"fs_imu\"],\n                self.dev_args[\"type\"],\n            )\n        else:\n            self._bdf_file = bdfSaverEMG(\n                filename,\n                self.dev_args[\"channel_emg\"],\n                self.dev_args[\"fs_emg\"],\n                self.dev_args[\"type\"],\n            )\n        self.__bdf_flag = True\n\n    def close_bdf_file(self):\n        \"\"\"\n        Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n        \"\"\"\n        self.__bdf_flag = False\n        if self._bdf_file is not None:\n            self._bdf_file.close_bdf()\n            self._bdf_file = None\n\n    def send_bdf_marker(self, marker: str):\n        \"\"\"\n        Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n        Args:\n            marker: marker string to write.\n        \"\"\"\n        if hasattr(self, \"_bdf_file\"):\n            self._bdf_file.write_Annotation(marker)\n\n    def close_dev(self):\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status != iFocus.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iFocus.Dev.TERMINATE_START\n            while self.__status != iFocus.Dev.TERMINATE:\n                time.sleep(0.1)\n        if self.is_alive():\n            self.join()\n\n    def __recv_data(self):\n        try:\n            self.dev.start_data()\n            self.__status = iFocus.Dev.SIGNAL\n        except Exception:\n            self.__socket_flag = \"SIGNAL mode initialization failed.\"\n            self.__status = iFocus.Dev.TERMINATE_START\n\n        while self.__status in [iFocus.Dev.SIGNAL]:\n            try:\n                data = self.dev.recv_socket()\n                if not data:\n                    raise Exception(\"Data transmission timeout.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    if self.__with_q:\n                        self.__save_data.put(ret)\n                    if self.__bdf_flag:\n                        self._bdf_file.write_chunk(ret)\n                    if self.__lsl_emg_flag:\n                        self._lsl_emg.push_chunk(\n                            [frame for frames in ret for frame in frames[:-1]]\n                        )\n                    if self.__lsl_imu_flag:\n                        self._lsl_imu.push_chunk([frame[-1] for frame in ret])\n                    if self.__lsl_emg_imu_flag:\n                        self._lsl_emg_imu.push_chunk(\n                            [frame for frames in ret for frame in frames[:-1]]\n                            + [frame[-1] for frame in ret]\n                        )\n            except Exception as e:\n                print(e)\n                self.__socket_flag = \"Data transmission timeout.\"\n                self.__status = iFocus.Dev.TERMINATE_START\n\n        # clear buffer\n        self.close_lsl_emg()\n        self.close_lsl_imu()\n        self.close_lsl_emg_imu()\n        self.close_bdf_file()\n        # self.dev.stop_recv()\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        # stop recv data\n        if self.__status != iFocus.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                if self.__status == iFocus.Dev.IDLE_START:\n                    self.__socket_flag = \"Connection lost.\"\n                self.__status = iFocus.Dev.TERMINATE_START\n\n    def run(self):\n        while self.__status != iFocus.Dev.TERMINATE_START:\n            if self.__status == iFocus.Dev.SIGNAL_START:\n                self.__recv_data()\n            elif self.__status == iFocus.Dev.IDLE_START:\n                self.__status = iFocus.Dev.IDLE\n                while self.__status == iFocus.Dev.IDLE:\n                    time.sleep(0.1)\n            else:\n                self.__socket_flag = f\"Unknown status: {self.__status.name}\"\n                break\n        try:\n            self.dev.close_socket()\n        finally:\n            self.__status = iFocus.Dev.TERMINATE\n\n    def __check_dev_status(self):\n        if self.__socket_flag is None:\n            return\n        if self.is_alive():\n            self.close_dev()\n        raise Exception(str(self.__socket_flag))\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>if not given, connect to the first available device.</p> <code>None</code> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def __init__(self, port: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Args:\n        port: if not given, connect to the first available device.\n    \"\"\"\n    super().__init__(daemon=True)\n    self.__status = iFocus.Dev.TERMINATE\n    if port is None:\n        port = iFocus.find_devs()[0]\n    self.__save_data = Queue()\n    self.__parser = Parser()\n    self.dev_args = deepcopy(iFocus.dev_args)\n    self.dev = sock(port)\n    self.set_frequency()\n    self.__with_q = True\n    self.__socket_flag = \"Device not connected, please connect first.\"\n    self.__bdf_flag = False\n    try:\n        self.dev.connect_socket()\n    except Exception as e:\n        try:\n            self.dev.close_socket()\n        finally:\n            raise e\n    self.__status = iFocus.Dev.IDLE_START\n    self.__socket_flag = None\n    self._lsl_emg = None\n    self._lsl_imu = None\n    self._lsl_emg_imu = None\n    self.__lsl_imu_flag = False\n    self.__lsl_emg_flag = False\n    self.__lsl_emg_imu_flag = False\n    self._bdf_file = None\n    self.__enable_imu = False\n    self.dev_args[\"name\"] = port\n    self.start()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_bdf_file","title":"<code>close_bdf_file()</code>","text":"<p>Close and save BDF file manually, invoked automatically after <code>stop_acquisition()</code> or <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_bdf_file(self):\n    \"\"\"\n    Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n    \"\"\"\n    self.__bdf_flag = False\n    if self._bdf_file is not None:\n        self._bdf_file.close_bdf()\n        self._bdf_file = None\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_dev(self):\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status != iFocus.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iFocus.Dev.TERMINATE_START\n        while self.__status != iFocus.Dev.TERMINATE:\n            time.sleep(0.1)\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_lsl_emg","title":"<code>close_lsl_emg()</code>","text":"<p>Close LSL EMG stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_lsl_emg(self):\n    \"\"\"\n    Close LSL EMG stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_emg_flag = False\n    if self._lsl_emg is not None:\n        self._lsl_emg = None\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_lsl_emg_imu","title":"<code>close_lsl_emg_imu()</code>","text":"<p>Close LSL EMG and IMU stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_lsl_emg_imu(self):\n    \"\"\"\n    Close LSL EMG and IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_emg_imu_flag = False\n    if self._lsl_emg_imu is not None:\n        self._lsl_emg_imu = None\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.close_lsl_imu","title":"<code>close_lsl_imu()</code>","text":"<p>Close LSL IMU stream manually, invoked automatically after <code>stop_acquisition()</code> and <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def close_lsl_imu(self):\n    \"\"\"\n    Close LSL IMU stream manually, invoked automatically after `stop_acquisition()` and `close_dev()`\n    \"\"\"\n    self.__lsl_imu_flag = False\n    if self._lsl_imu is not None:\n        self._lsl_imu = None\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.create_bdf_file","title":"<code>create_bdf_file(filename)</code>","text":"<p>Create a BDF file and save data to it, invoke it after <code>start_acquisition_data()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name to save data, accept absolute or relative path.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or <code>save_bdf_file</code> is invoked and BDF file already created.</p> <code>OSError</code> <p>if BDF file creation failed, this may be caused by invalid file path or permission issue.</p> <code>importError</code> <p>if <code>pyedflib</code> is not installed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def create_bdf_file(self, filename: str):\n    \"\"\"\n    Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n    Args:\n        filename: file name to save data, accept absolute or relative path.\n\n    Raises:\n        Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n        OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n        importError: if `pyedflib` is not installed.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started\")\n    if self._bdf_file is not None:\n        raise Exception(\"BDF file already created.\")\n    from ..utils.bdfWrapper import bdfSaverEMG, bdfSaverEMGIMU\n\n    if filename[-4:].lower() != \".bdf\":\n        filename += \".bdf\"\n    if self.__enable_imu:\n        self._bdf_file = bdfSaverEMGIMU(\n            filename,\n            self.dev_args[\"channel_emg\"],\n            self.dev_args[\"fs_emg\"],\n            self.dev_args[\"channel_imu\"],\n            self.dev_args[\"fs_imu\"],\n            self.dev_args[\"type\"],\n        )\n    else:\n        self._bdf_file = bdfSaverEMG(\n            filename,\n            self.dev_args[\"channel_emg\"],\n            self.dev_args[\"fs_emg\"],\n            self.dev_args[\"type\"],\n        )\n    self.__bdf_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.find_devs","title":"<code>find_devs()</code>  <code>staticmethod</code>","text":"<p>Find available iFocus devices.</p> <p>Returns:</p> Type Description <code>list</code> <p>available device ports.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if no iFocus device found.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>@staticmethod\ndef find_devs() -&gt; list:\n    \"\"\"\n    Find available iFocus devices.\n\n    Returns:\n        available device ports.\n\n    Raises:\n        Exception: if no iFocus device found.\n    \"\"\"\n    return sock._find_devs()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.get_data","title":"<code>get_data(timeout=0.02)</code>","text":"<p>Acquire all available data, make sure this function is called in a loop when <code>with_q</code> is set to <code>True</code> in<code>start_acquisition_data()</code></p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Non-negative value, blocks at most 'timeout' seconds and return, if set to <code>None</code>, blocks until new data available.</p> <code>0.02</code> <p>Returns:</p> Type Description <code>Optional[list[Optional[list]]]</code> <p>A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below: [[<code>emg_0</code>], [<code>emg_1</code>], [<code>emg_2</code>], [<code>emg_3</code>], [<code>emg_4</code>], [<code>imu_x</code>, <code>imu_y</code>, <code>imu_z</code>]],     in which number <code>0~4</code> after <code>_</code> indicates the time order of channel data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected, connection failed, data transmission timeout/init failed, or unknown error.</p> Data Unit <ul> <li>emg: \u00b5V</li> <li>imu: degree(\u00b0)</li> </ul> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def get_data(\n    self, timeout: Optional[float] = 0.02\n) -&gt; Optional[list[Optional[list]]]:\n    \"\"\"\n    Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n    Args:\n        timeout: Non-negative value, blocks at most 'timeout' seconds and return, if set to `None`, blocks until new data available.\n\n    Returns:\n        A list of frames, each frame is made up of 5 emg data and 1 imu data in a shape as below:\n            [[`emg_0`], [`emg_1`], [`emg_2`], [`emg_3`], [`emg_4`], [`imu_x`, `imu_y`, `imu_z`]],\n                in which number `0~4` after `_` indicates the time order of channel data.\n\n    Raises:\n        Exception: if device not connected, connection failed, data transmission timeout/init failed, or unknown error.\n\n    Data Unit:\n        - emg: \u00b5V\n        - imu: degree(\u00b0)\n    \"\"\"\n    self.__check_dev_status()\n    if not self.__with_q:\n        return\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.get_dev_info","title":"<code>get_dev_info()</code>","text":"<p>Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing device information, which includes: <code>type</code>: hardware type; <code>channel_emg</code>: channel dictionary, including EMG channel index and name; <code>channel_imu</code>: channel dictionary, including IMU channel index and name; <code>AdapterInfo</code>: adapter used for connection; <code>fs_emg</code>: sample frequency of EMG in Hz; <code>fs_imu</code>: sample frequency of IMU in Hz;</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def get_dev_info(self) -&gt; dict:\n    \"\"\"\n    Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n    Returns:\n        A dictionary containing device information, which includes:\n            `type`: hardware type;\n            `channel_emg`: channel dictionary, including EMG channel index and name;\n            `channel_imu`: channel dictionary, including IMU channel index and name;\n            `AdapterInfo`: adapter used for connection;\n            `fs_emg`: sample frequency of EMG in Hz;\n            `fs_imu`: sample frequency of IMU in Hz;\n    \"\"\"\n    return deepcopy(self.dev_args)\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.open_lsl_emg","title":"<code>open_lsl_emg()</code>","text":"<p>Open LSL EMG stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>ImportError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def open_lsl_emg(self):\n    \"\"\"\n    Open LSL EMG stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        ImportError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if self._lsl_emg is not None:\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    # Create an expanded channel dictionary for LSL stream creation,\n    # replicating each electrode label 'samples_per_packet' times.\n    expanded_channels = {}\n    current_key = 0\n    for label in self.dev_args[\"channel_emg\"].values():\n        for _ in range(self.dev_args[\"samples_per_packet\"]):\n            expanded_channels[current_key] = label\n            current_key += 1\n\n    # Use the expanded channel dictionary for initializing the LSL stream.\n    self._lsl_emg = lslSender(\n        expanded_channels,  # Expanded channels reflecting samples_per_packet.\n        f\"{self.dev_args['type']}EMG{self.dev_args['name'][-2:]}\",\n        \"EMG\",\n        self.dev_args[\"fs_emg\"],\n        with_trigger=False,\n    )\n    self.__lsl_emg_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.open_lsl_emg_imu","title":"<code>open_lsl_emg_imu()</code>","text":"<p>Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>ImportError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def open_lsl_emg_imu(self):\n    \"\"\"\n    Open LSL stream to transmit EMG and IMU simultaneously, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        ImportError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if self._lsl_emg_imu is not None:\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    key = 0\n    elctds = {}\n    # Expand EMG channels: repeat each EMG electrode label 'samples_per_packet' times.\n    for v in self.dev_args[\"channel_emg\"].values():\n        for _ in range(self.dev_args[\"samples_per_packet\"]):\n            elctds[key] = v\n            key += 1\n    # Add IMU channels as they are (no expansion)\n    for v in self.dev_args[\"channel_imu\"].values():\n        elctds[key] = v\n        key += 1\n\n    self._lsl_emg_imu = lslSender(\n        elctds,\n        f\"{self.dev_args['type']}EMG-IMU{self.dev_args['name'][-2:]}\",\n        \"EMG-IMU\",\n        self.dev_args[\"fs_emg\"] + self.dev_args[\"fs_imu\"],\n        unit=\"degree\",\n        with_trigger=False,\n    )\n    # Note: This combined LSL stream now reflects the expanded EMG channels\n    # and original IMU channels, ensuring the packet structure is maintained.\n    self.__lsl_emg_imu_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.open_lsl_imu","title":"<code>open_lsl_imu()</code>","text":"<p>Open LSL IMU stream, can be invoked after <code>start_acquisition_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> is not installed or liblsl not installed for unix like system.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def open_lsl_imu(self):\n    \"\"\"\n    Open LSL IMU stream, can be invoked after `start_acquisition_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` is not installed or liblsl not installed for unix like system.\n    \"\"\"\n    if self.__status != iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if self._lsl_imu is not None:\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_imu = lslSender(\n        self.dev_args[\"channel_imu\"],\n        f\"{self.dev_args['type']}IMU{self.dev_args['name'][-2:]}\",\n        \"IMU\",\n        self.dev_args[\"fs_imu\"],\n        unit=\"degree\",\n        with_trigger=False,\n    )\n    self.__lsl_imu_flag = True\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.send_bdf_marker","title":"<code>send_bdf_marker(marker)</code>","text":"<p>Send marker to BDF file, can be invoked after <code>create_bdf_file()</code>, otherwise it will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>str</code> <p>marker string to write.</p> required Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def send_bdf_marker(self, marker: str):\n    \"\"\"\n    Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n    Args:\n        marker: marker string to write.\n    \"\"\"\n    if hasattr(self, \"_bdf_file\"):\n        self._bdf_file.write_Annotation(marker)\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.set_frequency","title":"<code>set_frequency(fs_emg=None)</code>","text":"<p>Change the sampling frequency of iFocus.</p> <p>Parameters:</p> Name Type Description Default <code>fs_emg</code> <code>int</code> <p>sampling frequency of emg data, should be 250 or 500, fs_imu will be automatically set to 1/5 of fs_emg.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if fs_emg is not 250 or 500.</p> <code>NotImplementedError</code> <p>device firmware too old, not supporting 500Hz.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def set_frequency(self, fs_emg: int = None):\n    \"\"\"\n    Change the sampling frequency of iFocus.\n\n    Args:\n        fs_emg: sampling frequency of emg data, should be 250 or 500,\n            fs_imu will be automatically set to 1/5 of fs_emg.\n\n    Raises:\n        ValueError: if fs_emg is not 250 or 500.\n        NotImplementedError: device firmware too old, not supporting 500Hz.\n    \"\"\"\n    if self.__status == iFocus.Dev.SIGNAL:\n        raise Exception(\"Data acquisition already started, please stop first.\")\n    if fs_emg is None:\n        fs_emg = self.dev_args[\"fs_emg\"]\n    if fs_emg not in [250, 500]:\n        raise ValueError(\"fs_emg should be 250 or 500\")\n    self.dev_args[\"fs_emg\"] = fs_emg\n    fs_imu = fs_emg // 5\n    self.dev_args[\"fs_imu\"] = fs_imu\n    if hasattr(self, \"dev\"):\n        self.dev.set_frequency(fs_emg)\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.start_acquisition_data","title":"<code>start_acquisition_data(with_q=True)</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> <p>Parameters:</p> Name Type Description Default <code>with_q</code> <code>bool</code> <p>if True, signal data will be stored in a queue and should be acquired by calling <code>get_data()</code> in a loop in case data queue is full. if False, new data will not be directly available and can only be acquired through lsl stream.</p> <code>True</code> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def start_acquisition_data(self, with_q: bool = True) -&gt; None:\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n\n    Args:\n        with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n            if False, new data will not be directly available and can only be acquired through lsl stream.\n\n    \"\"\"\n    self.__check_dev_status()\n    self.__with_q = with_q\n    if self.__status == iFocus.Dev.SIGNAL:\n        return\n    self.__status = iFocus.Dev.SIGNAL_START\n    while self.__status not in [iFocus.Dev.SIGNAL, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iFocus/#eConEXG.iFocus.iFocus.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> Source code in <code>src\\eConEXG\\iFocus\\data_reader.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n    \"\"\"\n    self.__check_dev_status()\n    self.__status = iFocus.Dev.IDLE_START\n    while self.__status not in [iFocus.Dev.IDLE, iFocus.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iRecorder/","title":"iRecorder","text":""},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder","title":"<code>iRecorder</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>class iRecorder(Thread):\n    class Dev(Enum):\n        SIGNAL = 10  # signal transmission mode\n        SIGNAL_START = 11\n        IMPEDANCE = 20  # impedance transmission mode\n        IMPEDANCE_START = 21\n        IDLE = 30  # idle mode\n        IDLE_START = 31\n        TERMINATE = 40  # Init state\n        TERMINATE_START = 41\n\n    def __init__(self, dev_type: str):\n        \"\"\"\n        Args:\n            dev_type: iRecorder device type. available options: Literal[\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"]\n        Raises:\n            Exception: if device type not supported.\n            Exception: if adapter not available.\n        \"\"\"\n        if dev_type not in {\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"}:\n            raise ValueError(\"Unsupported device type.\")\n        super().__init__(daemon=True, name=f\"iRecorder {dev_type}\")\n        self.handler = None\n        self.__info_q = Queue(128)\n        self.__with_q = True\n        self.__error_message = \"Device not connected, please connect first.\"\n        self.__save_data = Queue()\n        self.__update_func = None\n        self.__status = iRecorder.Dev.TERMINATE\n        self.__lsl_flag = False\n        self.__bdf_flag = False\n        self.__dev_args = {\"type\": dev_type}\n        self.__dev_args.update({\"channel\": self.__get_chs()})\n\n        self.__parser = Parser(self.__dev_args[\"channel\"])\n        self.__interface = get_interface(dev_type, self.__info_q)\n        self.__dev_sock = get_sock(dev_type)\n        self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n        self._bdf_file = None\n        self.dev = None\n\n        self.set_frequency()\n        self.update_channels()\n\n    def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n        \"\"\"\n        Search for available devices, can only be called once per instance.\n\n        Args:\n            duration: Search interval in seconds, blocks for about `duration` seconds and return found devices,\n                if set to `None`, return `None` immediately, devices can later be acquired by calling `get_devs()` in a loop.\n\n        Returns:\n            Available devices.\n\n        Raises:\n            Exception: If search thread already running or iRecorder already connected.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected.\")\n        if self.__interface.is_alive():\n            raise Exception(\"Search thread already running.\")\n        self.__interface.start()\n        if duration is None:\n            return\n        start = time.time()\n        while time.time() - start &lt; duration:\n            time.sleep(0.5)\n        self.__finish_search()\n        return self.get_devs()\n\n    def get_devs(self, verbose: bool = False) -&gt; list:\n        \"\"\"\n        Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n            each call will *only* return newly found devices.\n\n        Args:\n            verbose: if True, return all available devices information, otherwise only return names for connection,\n                if you don't know what this parameter does, just leave it at its default value.\n\n        Returns:\n            Newly found devices.\n\n        Raises:\n            Exception: adapter not found or not enabled etc.\n        \"\"\"\n        ret = []\n        time.sleep(0.1)\n        while not self.__info_q.empty():\n            info = self.__info_q.get()\n            if isinstance(info, list):\n                ret.append(info if verbose else info[-1])\n            elif isinstance(info, bool):\n                if verbose:\n                    ret.append(info)\n            elif isinstance(info, str):\n                raise Exception(info)\n        return ret\n\n    def get_dev_status(self) -&gt; str:\n        \"\"\"\n        Get current device status.\n\n        Returns:\n            \"SIGNAL\": data acquisition mode\n            \"IMPEDANCE\": impedance acquisition mode\n            \"IDLE\": idle mode\n            \"TERMINATE\": device not connected or connection closed.\n        \"\"\"\n        return self.__status.name\n\n    def get_dev_info(self) -&gt; dict:\n        \"\"\"\n        Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n        Returns:\n            A dictionary containing device information, which includes:\n                `type`: hardware type;\n                `channel`: hardware channel number;\n                `AdapterInfo`: adapter used for connection;\n                `fs`: sample frequency in Hz;\n                `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n        \"\"\"\n        return deepcopy(self.__dev_args)\n\n    @staticmethod\n    def get_available_frequency(dev_type: str) -&gt; list:\n        \"\"\"Get available sample frequencies of different device types.\n\n        Returns:\n            Available sample frequencies in Hz.\n        \"\"\"\n        if \"USB\" in dev_type:\n            return [500, 1000, 2000]\n        return [500]\n\n    def set_frequency(self, fs: Optional[int] = None):\n        \"\"\"Update device sample frequency, this method should be invoked before `connect_device`.\n\n        Args:\n            fs: sample frequency in Hz, if `fs` is set to `None` or not in `get_available_frequency()`,\n                it will fall back to the lowest available frequency.\n\n        Raises:\n            Exception: Device is already connected.\n\n        New in:\n            - now you can set the sample frequency after device connection.\n        \"\"\"\n        if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            warn = \"Device acquisition in progress, please `stop_acquisition()` first.\"\n            raise Exception(warn)\n        available = self.get_available_frequency(self.__dev_args[\"type\"])\n        default = available[0]\n        if fs is None:\n            fs = default\n        if fs not in available:\n            print(f\"Invalid sample frequency, fallback to {default}Hz\")\n            fs = default\n        self.__dev_args.update({\"fs\": fs})\n        self.__parser._update_fs(fs)\n        if self.dev is not None:\n            self.dev.set_fs(fs)\n\n    def connect_device(self, addr: str) -&gt; None:\n        \"\"\"\n        Connect to device by address, block until connection is established or failed.\n\n        Args:\n            addr: device address.\n\n        Raises:\n            Exception: if device already connected or connection establishment failed.\n        \"\"\"\n        if self.is_alive():\n            raise Exception(\"iRecorder already connected\")\n        try:\n            ret = self.__interface.connect(addr)\n            self.__dev_args.update({\"name\": addr, \"sock\": ret})\n            self.__dev_args.update({\"_length\": self.__parser.packet_len})\n            self.dev = self.__dev_sock(self.__dev_args)\n            self.__parser.batt_val = self.dev.send_heartbeat()\n            self.__error_message = None\n            self.__status = iRecorder.Dev.IDLE_START\n            self.start()\n        except Exception as e:\n            self.__error_message = \"Device connection failed.\"\n            self.__finish_search()\n            raise e\n\n    def update_channels(self, channels: Optional[dict] = None):\n        \"\"\"\n        Update channels to acquire, invoke this method when device is not acquiring data or impedance.\n\n        Args:\n            channels: channel number and name mapping, e.g. `{0: \"FPz\", 1: \"Oz\", 2: \"CPz\"}`,\n                if `None` is given, reset to all available channels with default names.\n\n        Raises:\n            Exception: if data/impedance acquisition in progress.\n        \"\"\"\n        if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            warn = \"Device acquisition in progress, please stop_acquisition() first.\"\n            raise Exception(warn)\n        if channels is None:\n            from .default_config import getChannels\n\n            channels = getChannels(self.__dev_args[\"channel\"])\n        self.__dev_args.update({\"ch_info\": channels})\n        ch_idx = [i for i in channels.keys()]\n        self.__parser._update_chs(ch_idx)\n\n    def start_acquisition_data(self, with_q: bool = True):\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n\n        Args:\n            with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n                if False and __update_func has been set up, data will be passed this functions directly, which is more efficient in multithread and multiprocess(with shared memory).\n                data can also be acquired through `open_lsl_stream` and `save_bdf_file`.\n\n        Raises:\n            Exception: if device not connected or data acquisition init failed.\n        \"\"\"\n        self.__check_dev_status()\n        self.__with_q = with_q\n        if self.__status == iRecorder.Dev.SIGNAL:\n            return\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.SIGNAL_START\n        while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def set_update_functions(\n        self, function: Callable[[numpy.array], None] = None\n    ) -&gt; None:\n        \"\"\"\n        set the out of class function, invoked automatically tp process data when self.__with_q is False.\n\n        Args:\n            function: The target function\n        \"\"\"\n        self.__update_func = function\n\n    def get_data(\n        self, timeout: Optional[float] = 0.02\n    ) -&gt; Optional[list[Optional[list]]]:\n        \"\"\"\n        Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n        Args:\n            timeout: Non-negative value, blocks at most `timeout` seconds and return, if set to `None`, blocks until new data is available.\n\n        Returns:\n            A list of frames, each frame is a list contains all wanted eeg channels and trigger box channel,\n                eeg channels can be updated by `update_channels()`.\n\n        Data Unit:\n            - eeg: micro volts (\u00b5V)\n            - triggerbox: int, from `0` to `255`\n\n        Raises:\n            Exception: if device not connected or in data acquisition mode.\n        \"\"\"\n        self.__check_dev_status()\n        if not self.__with_q:\n            return\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n        Raises:\n            Exception: if device not connected or acquisition stop failed.\n        \"\"\"\n        self.__check_dev_status()\n        if self.__status == iRecorder.Dev.IDLE:\n            return\n        self.__status = iRecorder.Dev.IDLE_START\n        while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def start_acquisition_impedance(self) -&gt; None:\n        \"\"\"\n        Send impedance acquisition command to device, block until data acquisition started or failed.\n\n        Raises:\n            Exception: if device not connected or impedance acquisition init failed.\n        \"\"\"\n        self.__check_dev_status()\n        if self.__status == iRecorder.Dev.IMPEDANCE:\n            return\n        if self.__status == iRecorder.Dev.SIGNAL:\n            self.stop_acquisition()\n        self.__status = iRecorder.Dev.IMPEDANCE_START\n        while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n            time.sleep(0.01)\n        self.__check_dev_status()\n\n    def get_impedance(self) -&gt; Optional[list]:\n        \"\"\"\n        Acquire channel impedances, return immediately, impedance update interval is about 2000ms.\n\n        Returns:\n            A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n        Data Unit:\n            - impedance: ohm (\u03a9)\n        \"\"\"\n        self.__check_dev_status()\n        return self.__parser.impedance\n\n    def close_dev(self) -&gt; None:\n        \"\"\"\n        Close device connection and release resources, resources are automatically released on device error.\n        \"\"\"\n        if self.__status != iRecorder.Dev.TERMINATE:\n            # ensure socket is closed correctly\n            self.__status = iRecorder.Dev.TERMINATE_START\n            while self.__status != iRecorder.Dev.TERMINATE:\n                time.sleep(0.01)\n        if self.is_alive():\n            self.join()\n\n    def get_packet_drop_times(self) -&gt; int:\n        \"\"\"\n        Retrieve packet drop times.\n        This value accumulates during data transmission and will be reset to `0` after device status change.\n\n        Returns:\n            accumulated packet drop times.\n        \"\"\"\n        return self.__parser._drop_count\n\n    def get_battery_value(self) -&gt; int:\n        \"\"\"\n        Query battery level.\n\n        Returns:\n            battery level in percentage, range from `0` to `100`.\n        \"\"\"\n        return self.__parser.batt_val\n\n    def open_lsl_stream(self):\n        \"\"\"\n        Open LSL stream, can be invoked after `start_acquisition_data()`,\n            each frame is the same as described in `get_data()`.\n\n        Raises:\n            Exception: if data acquisition not started or LSL stream already opened.\n            LSLException: if LSL stream creation failed.\n            importError: if `pylsl` not installed or liblsl not installed on unix like system.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started, please start first.\")\n        if hasattr(self, \"_lsl_stream\"):\n            raise Exception(\"LSL stream already opened.\")\n        from ..utils.lslWrapper import lslSender\n\n        self._lsl_stream = lslSender(\n            self.__dev_args[\"ch_info\"],\n            f\"iRe{self.__dev_args['type']}_{self.__dev_args['name'][-2:]}\",\n            \"EEG\",\n            self.__dev_args[\"fs\"],\n            with_trigger=True,\n        )\n        self.__lsl_flag = True\n\n    def close_lsl_stream(self):\n        \"\"\"\n        Close LSL stream manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n        \"\"\"\n        self.__lsl_flag = False\n        if hasattr(self, \"_lsl_stream\"):\n            del self._lsl_stream\n\n    def create_bdf_file(self, filename: str):\n        \"\"\"\n        Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n        Args:\n            filename: file name to save data, accept absolute or relative path.\n\n        Raises:\n            Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n            OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n            importError: if `pyedflib` is not installed.\n        \"\"\"\n        if self.__status != iRecorder.Dev.SIGNAL:\n            raise Exception(\"Data acquisition not started\")\n        if self._bdf_file is not None:\n            raise Exception(\"BDF file already created.\")\n        from ..utils.bdfWrapper import bdfSaverIRecorder\n\n        if filename[-4:].lower() != \".bdf\":\n            filename += \".bdf\"\n        self._bdf_file = bdfSaverIRecorder(\n            filename,\n            self.__dev_args[\"ch_info\"],\n            self.__dev_args[\"fs\"],\n            f\"iRecorder_{self.__dev_args['type']}_{self.__dev_args['name']}\",\n        )\n        self.__bdf_flag = True\n\n    def close_bdf_file(self):\n        \"\"\"\n        Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n        \"\"\"\n        self.__bdf_flag = False\n        if self._bdf_file is not None:\n            self._bdf_file.close_bdf()\n            self._bdf_file = None\n\n    def send_bdf_marker(self, marker: str):\n        \"\"\"\n        Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n        Args:\n            marker: marker string to write.\n        \"\"\"\n        if self._bdf_file is not None:\n            self._bdf_file.write_Annotation(marker)\n\n    # def set_callback_handler(self, handler: Callable[[Optional[str]], None]):\n    #     \"\"\"\n    #     Set callback handler function, invoked automatically when device thread ended if set.\n\n    #     Args:\n    #         handler: a callable function that takes a string of error message or `None` as input.\n    #     \"\"\"\n    #     self.handler = handler\n\n    def __check_dev_status(self):\n        if self.__error_message is None:\n            return\n        if self.is_alive():\n            self.close_dev()\n        raise Exception(self.__error_message)\n\n    def run(self):\n        while self.__status not in [iRecorder.Dev.TERMINATE_START]:\n            if self.__status == iRecorder.Dev.SIGNAL_START:\n                self.__recv_data(imp_mode=False)\n            elif self.__status == iRecorder.Dev.IMPEDANCE_START:\n                self.__recv_data(imp_mode=True)\n            elif self.__status in [iRecorder.Dev.IDLE_START]:\n                self.__idle_state()\n            else:\n                self.__error_message = f\"Unknown status: {self.__status}\"\n                break\n        try:\n            self.dev.close_socket()\n        except Exception:\n            pass\n        finally:\n            self.__finish_search()\n            self.__status = iRecorder.Dev.TERMINATE\n        # if self.handler is not None:\n        #     self.handler(self.__error_message)\n\n    def __recv_data(self, imp_mode=True):\n        self.__parser.imp_flag = imp_mode\n        retry = 0\n        try:\n            if imp_mode:\n                self.dev.start_impe()\n                self.__status = iRecorder.Dev.IMPEDANCE\n                print(\"IMPEDANCE START\")\n            else:\n                self.dev.start_data()\n                self.__status = iRecorder.Dev.SIGNAL\n                print(\"SIGNAL START\")\n        except Exception:\n            self.__error_message = \"Data/Impedance mode initialization failed.\"\n            self.__status = iRecorder.Dev.TERMINATE_START\n        # recv data\n        while self.__status in [iRecorder.Dev.SIGNAL, iRecorder.Dev.IMPEDANCE]:\n            try:\n                data = self.dev.recv_socket()\n                if not data:\n                    raise Exception(\"Remote end closed.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    if self.__with_q:\n                        self.__save_data.put(ret)\n                    elif isinstance(self.__update_func, Callable):\n                        ret_array = np.array(ret).T\n                        if ret_array.size &gt; 0:\n                            self.__update_func(ret_array)\n                    if self.__bdf_flag:\n                        self._bdf_file.write_chunk(ret)\n                    if self.__lsl_flag:\n                        self._lsl_stream.push_chunk(ret)\n            except Exception:\n                traceback.print_exc()\n                if (self.__dev_args[\"type\"] == \"W32\") and (retry &lt; 1):\n                    try:\n                        print(\"Wi-Fi reconnecting...\")\n                        self.dev.close_socket()\n                        self.dev = self.__dev_sock(self.__dev_args, retry_timeout=3)\n                        retry += 1\n                        continue\n                    except Exception:\n                        print(\"Wi-Fi reconnection failed\")\n                self.__error_message = \"Data transmission timeout.\"\n                self.__status = iRecorder.Dev.TERMINATE_START\n        # postprocess\n        self.close_bdf_file()\n        self.close_lsl_stream()\n        self.__parser.clear_buffer()\n        while not self.__save_data.empty():\n            self.__save_data.get()\n        # stop recv data\n        if self.__status != iRecorder.Dev.TERMINATE_START:\n            try:  # stop data acquisition when thread ended\n                self.dev.stop_recv()\n            except Exception:\n                traceback.print_exc()\n                if self.__status == iRecorder.Dev.IDLE_START:\n                    self.__error_message = \"Device connection lost.\"\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n    def __idle_state(self):\n        timestamp = time.time()\n        self.__status = iRecorder.Dev.IDLE\n        while self.__status in [iRecorder.Dev.IDLE]:\n            if (time.time() - timestamp) &lt; 5:\n                time.sleep(0.2)  # to reduce cpu usage\n                continue\n            try:  # heartbeat to keep socket alive and update battery level\n                self.__parser.batt_val = self.dev.send_heartbeat()\n                timestamp = time.time()\n                # print(\"Ah, ah, ah, ah\\nStayin' alive, stayin' alive\")\n            except Exception:\n                traceback.print_exc()\n                self.__error_message = \"Device connection lost.\"\n                self.__status = iRecorder.Dev.TERMINATE_START\n\n    def __get_chs(self) -&gt; int:\n        return int(\"\".join([i for i in self.__dev_args[\"type\"] if i.isdigit()]))\n\n    def __finish_search(self):\n        if self.__interface.is_alive():\n            self.__interface.stop()\n            self.__interface.join()\n        while not self.__info_q.empty():\n            self.__info_q.get()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.__init__","title":"<code>__init__(dev_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dev_type</code> <code>str</code> <p>iRecorder device type. available options: Literal[\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"]</p> required <p>Raises:     Exception: if device type not supported.     Exception: if adapter not available.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def __init__(self, dev_type: str):\n    \"\"\"\n    Args:\n        dev_type: iRecorder device type. available options: Literal[\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"]\n    Raises:\n        Exception: if device type not supported.\n        Exception: if adapter not available.\n    \"\"\"\n    if dev_type not in {\"W8\", \"USB8\", \"W16\", \"USB16\", \"W32\", \"USB32\"}:\n        raise ValueError(\"Unsupported device type.\")\n    super().__init__(daemon=True, name=f\"iRecorder {dev_type}\")\n    self.handler = None\n    self.__info_q = Queue(128)\n    self.__with_q = True\n    self.__error_message = \"Device not connected, please connect first.\"\n    self.__save_data = Queue()\n    self.__update_func = None\n    self.__status = iRecorder.Dev.TERMINATE\n    self.__lsl_flag = False\n    self.__bdf_flag = False\n    self.__dev_args = {\"type\": dev_type}\n    self.__dev_args.update({\"channel\": self.__get_chs()})\n\n    self.__parser = Parser(self.__dev_args[\"channel\"])\n    self.__interface = get_interface(dev_type, self.__info_q)\n    self.__dev_sock = get_sock(dev_type)\n    self.__dev_args.update({\"AdapterInfo\": self.__interface.interface})\n\n    self._bdf_file = None\n    self.dev = None\n\n    self.set_frequency()\n    self.update_channels()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_bdf_file","title":"<code>close_bdf_file()</code>","text":"<p>Close and save BDF file manually, invoked automatically after <code>stop_acquisition()</code> or <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_bdf_file(self):\n    \"\"\"\n    Close and save BDF file manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n    \"\"\"\n    self.__bdf_flag = False\n    if self._bdf_file is not None:\n        self._bdf_file.close_bdf()\n        self._bdf_file = None\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources, resources are automatically released on device error.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_dev(self) -&gt; None:\n    \"\"\"\n    Close device connection and release resources, resources are automatically released on device error.\n    \"\"\"\n    if self.__status != iRecorder.Dev.TERMINATE:\n        # ensure socket is closed correctly\n        self.__status = iRecorder.Dev.TERMINATE_START\n        while self.__status != iRecorder.Dev.TERMINATE:\n            time.sleep(0.01)\n    if self.is_alive():\n        self.join()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.close_lsl_stream","title":"<code>close_lsl_stream()</code>","text":"<p>Close LSL stream manually, invoked automatically after <code>stop_acquisition()</code> or <code>close_dev()</code></p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def close_lsl_stream(self):\n    \"\"\"\n    Close LSL stream manually, invoked automatically after `stop_acquisition()` or `close_dev()`\n    \"\"\"\n    self.__lsl_flag = False\n    if hasattr(self, \"_lsl_stream\"):\n        del self._lsl_stream\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.connect_device","title":"<code>connect_device(addr)</code>","text":"<p>Connect to device by address, block until connection is established or failed.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>device address.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if device already connected or connection establishment failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def connect_device(self, addr: str) -&gt; None:\n    \"\"\"\n    Connect to device by address, block until connection is established or failed.\n\n    Args:\n        addr: device address.\n\n    Raises:\n        Exception: if device already connected or connection establishment failed.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected\")\n    try:\n        ret = self.__interface.connect(addr)\n        self.__dev_args.update({\"name\": addr, \"sock\": ret})\n        self.__dev_args.update({\"_length\": self.__parser.packet_len})\n        self.dev = self.__dev_sock(self.__dev_args)\n        self.__parser.batt_val = self.dev.send_heartbeat()\n        self.__error_message = None\n        self.__status = iRecorder.Dev.IDLE_START\n        self.start()\n    except Exception as e:\n        self.__error_message = \"Device connection failed.\"\n        self.__finish_search()\n        raise e\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.create_bdf_file","title":"<code>create_bdf_file(filename)</code>","text":"<p>Create a BDF file and save data to it, invoke it after <code>start_acquisition_data()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>file name to save data, accept absolute or relative path.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or <code>save_bdf_file</code> is invoked and BDF file already created.</p> <code>OSError</code> <p>if BDF file creation failed, this may be caused by invalid file path or permission issue.</p> <code>importError</code> <p>if <code>pyedflib</code> is not installed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def create_bdf_file(self, filename: str):\n    \"\"\"\n    Create a BDF file and save data to it, invoke it after `start_acquisition_data()`.\n\n    Args:\n        filename: file name to save data, accept absolute or relative path.\n\n    Raises:\n        Exception: if data acquisition not started or `save_bdf_file` is invoked and BDF file already created.\n        OSError: if BDF file creation failed, this may be caused by invalid file path or permission issue.\n        importError: if `pyedflib` is not installed.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started\")\n    if self._bdf_file is not None:\n        raise Exception(\"BDF file already created.\")\n    from ..utils.bdfWrapper import bdfSaverIRecorder\n\n    if filename[-4:].lower() != \".bdf\":\n        filename += \".bdf\"\n    self._bdf_file = bdfSaverIRecorder(\n        filename,\n        self.__dev_args[\"ch_info\"],\n        self.__dev_args[\"fs\"],\n        f\"iRecorder_{self.__dev_args['type']}_{self.__dev_args['name']}\",\n    )\n    self.__bdf_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.find_devs","title":"<code>find_devs(duration=None)</code>","text":"<p>Search for available devices, can only be called once per instance.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[int]</code> <p>Search interval in seconds, blocks for about <code>duration</code> seconds and return found devices, if set to <code>None</code>, return <code>None</code> immediately, devices can later be acquired by calling <code>get_devs()</code> in a loop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>Available devices.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If search thread already running or iRecorder already connected.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def find_devs(self, duration: Optional[int] = None) -&gt; Optional[list]:\n    \"\"\"\n    Search for available devices, can only be called once per instance.\n\n    Args:\n        duration: Search interval in seconds, blocks for about `duration` seconds and return found devices,\n            if set to `None`, return `None` immediately, devices can later be acquired by calling `get_devs()` in a loop.\n\n    Returns:\n        Available devices.\n\n    Raises:\n        Exception: If search thread already running or iRecorder already connected.\n    \"\"\"\n    if self.is_alive():\n        raise Exception(\"iRecorder already connected.\")\n    if self.__interface.is_alive():\n        raise Exception(\"Search thread already running.\")\n    self.__interface.start()\n    if duration is None:\n        return\n    start = time.time()\n    while time.time() - start &lt; duration:\n        time.sleep(0.5)\n    self.__finish_search()\n    return self.get_devs()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_available_frequency","title":"<code>get_available_frequency(dev_type)</code>  <code>staticmethod</code>","text":"<p>Get available sample frequencies of different device types.</p> <p>Returns:</p> Type Description <code>list</code> <p>Available sample frequencies in Hz.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>@staticmethod\ndef get_available_frequency(dev_type: str) -&gt; list:\n    \"\"\"Get available sample frequencies of different device types.\n\n    Returns:\n        Available sample frequencies in Hz.\n    \"\"\"\n    if \"USB\" in dev_type:\n        return [500, 1000, 2000]\n    return [500]\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_battery_value","title":"<code>get_battery_value()</code>","text":"<p>Query battery level.</p> <p>Returns:</p> Type Description <code>int</code> <p>battery level in percentage, range from <code>0</code> to <code>100</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_battery_value(self) -&gt; int:\n    \"\"\"\n    Query battery level.\n\n    Returns:\n        battery level in percentage, range from `0` to `100`.\n    \"\"\"\n    return self.__parser.batt_val\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_data","title":"<code>get_data(timeout=0.02)</code>","text":"<p>Acquire all available data, make sure this function is called in a loop when <code>with_q</code> is set to <code>True</code> in<code>start_acquisition_data()</code></p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Non-negative value, blocks at most <code>timeout</code> seconds and return, if set to <code>None</code>, blocks until new data is available.</p> <code>0.02</code> <p>Returns:</p> Type Description <code>Optional[list[Optional[list]]]</code> <p>A list of frames, each frame is a list contains all wanted eeg channels and trigger box channel, eeg channels can be updated by <code>update_channels()</code>.</p> Data Unit <ul> <li>eeg: micro volts (\u00b5V)</li> <li>triggerbox: int, from <code>0</code> to <code>255</code></li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or in data acquisition mode.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_data(\n    self, timeout: Optional[float] = 0.02\n) -&gt; Optional[list[Optional[list]]]:\n    \"\"\"\n    Acquire all available data, make sure this function is called in a loop when `with_q` is set to `True` in`start_acquisition_data()`\n\n    Args:\n        timeout: Non-negative value, blocks at most `timeout` seconds and return, if set to `None`, blocks until new data is available.\n\n    Returns:\n        A list of frames, each frame is a list contains all wanted eeg channels and trigger box channel,\n            eeg channels can be updated by `update_channels()`.\n\n    Data Unit:\n        - eeg: micro volts (\u00b5V)\n        - triggerbox: int, from `0` to `255`\n\n    Raises:\n        Exception: if device not connected or in data acquisition mode.\n    \"\"\"\n    self.__check_dev_status()\n    if not self.__with_q:\n        return\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_info","title":"<code>get_dev_info()</code>","text":"<p>Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing device information, which includes: <code>type</code>: hardware type; <code>channel</code>: hardware channel number; <code>AdapterInfo</code>: adapter used for connection; <code>fs</code>: sample frequency in Hz; <code>ch_info</code>: channel dictionary, including channel index and name, can be altered by <code>update_channels()</code>.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_info(self) -&gt; dict:\n    \"\"\"\n    Get current device information, including device name, hardware channel number, acquired channels, sample frequency, etc.\n\n    Returns:\n        A dictionary containing device information, which includes:\n            `type`: hardware type;\n            `channel`: hardware channel number;\n            `AdapterInfo`: adapter used for connection;\n            `fs`: sample frequency in Hz;\n            `ch_info`: channel dictionary, including channel index and name, can be altered by `update_channels()`.\n    \"\"\"\n    return deepcopy(self.__dev_args)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_dev_status","title":"<code>get_dev_status()</code>","text":"<p>Get current device status.</p> <p>Returns:</p> Type Description <code>str</code> <p>\"SIGNAL\": data acquisition mode</p> <code>str</code> <p>\"IMPEDANCE\": impedance acquisition mode</p> <code>str</code> <p>\"IDLE\": idle mode</p> <code>str</code> <p>\"TERMINATE\": device not connected or connection closed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_dev_status(self) -&gt; str:\n    \"\"\"\n    Get current device status.\n\n    Returns:\n        \"SIGNAL\": data acquisition mode\n        \"IMPEDANCE\": impedance acquisition mode\n        \"IDLE\": idle mode\n        \"TERMINATE\": device not connected or connection closed.\n    \"\"\"\n    return self.__status.name\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_devs","title":"<code>get_devs(verbose=False)</code>","text":"<p>Get available devices. This can be called after <code>find_devs(duration = None)</code> in a loop,     each call will only return newly found devices.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>if True, return all available devices information, otherwise only return names for connection, if you don't know what this parameter does, just leave it at its default value.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>Newly found devices.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>adapter not found or not enabled etc.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_devs(self, verbose: bool = False) -&gt; list:\n    \"\"\"\n    Get available devices. This can be called after `find_devs(duration = None)` in a loop,\n        each call will *only* return newly found devices.\n\n    Args:\n        verbose: if True, return all available devices information, otherwise only return names for connection,\n            if you don't know what this parameter does, just leave it at its default value.\n\n    Returns:\n        Newly found devices.\n\n    Raises:\n        Exception: adapter not found or not enabled etc.\n    \"\"\"\n    ret = []\n    time.sleep(0.1)\n    while not self.__info_q.empty():\n        info = self.__info_q.get()\n        if isinstance(info, list):\n            ret.append(info if verbose else info[-1])\n        elif isinstance(info, bool):\n            if verbose:\n                ret.append(info)\n        elif isinstance(info, str):\n            raise Exception(info)\n    return ret\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_impedance","title":"<code>get_impedance()</code>","text":"<p>Acquire channel impedances, return immediately, impedance update interval is about 2000ms.</p> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>A list of channel impedance ranging from <code>0</code> to <code>np.inf</code> if available, otherwise <code>None</code>.</p> Data Unit <ul> <li>impedance: ohm (\u03a9)</li> </ul> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_impedance(self) -&gt; Optional[list]:\n    \"\"\"\n    Acquire channel impedances, return immediately, impedance update interval is about 2000ms.\n\n    Returns:\n        A list of channel impedance ranging from `0` to `np.inf` if available, otherwise `None`.\n\n    Data Unit:\n        - impedance: ohm (\u03a9)\n    \"\"\"\n    self.__check_dev_status()\n    return self.__parser.impedance\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.get_packet_drop_times","title":"<code>get_packet_drop_times()</code>","text":"<p>Retrieve packet drop times. This value accumulates during data transmission and will be reset to <code>0</code> after device status change.</p> <p>Returns:</p> Type Description <code>int</code> <p>accumulated packet drop times.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def get_packet_drop_times(self) -&gt; int:\n    \"\"\"\n    Retrieve packet drop times.\n    This value accumulates during data transmission and will be reset to `0` after device status change.\n\n    Returns:\n        accumulated packet drop times.\n    \"\"\"\n    return self.__parser._drop_count\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.open_lsl_stream","title":"<code>open_lsl_stream()</code>","text":"<p>Open LSL stream, can be invoked after <code>start_acquisition_data()</code>,     each frame is the same as described in <code>get_data()</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if data acquisition not started or LSL stream already opened.</p> <code>LSLException</code> <p>if LSL stream creation failed.</p> <code>importError</code> <p>if <code>pylsl</code> not installed or liblsl not installed on unix like system.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def open_lsl_stream(self):\n    \"\"\"\n    Open LSL stream, can be invoked after `start_acquisition_data()`,\n        each frame is the same as described in `get_data()`.\n\n    Raises:\n        Exception: if data acquisition not started or LSL stream already opened.\n        LSLException: if LSL stream creation failed.\n        importError: if `pylsl` not installed or liblsl not installed on unix like system.\n    \"\"\"\n    if self.__status != iRecorder.Dev.SIGNAL:\n        raise Exception(\"Data acquisition not started, please start first.\")\n    if hasattr(self, \"_lsl_stream\"):\n        raise Exception(\"LSL stream already opened.\")\n    from ..utils.lslWrapper import lslSender\n\n    self._lsl_stream = lslSender(\n        self.__dev_args[\"ch_info\"],\n        f\"iRe{self.__dev_args['type']}_{self.__dev_args['name'][-2:]}\",\n        \"EEG\",\n        self.__dev_args[\"fs\"],\n        with_trigger=True,\n    )\n    self.__lsl_flag = True\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.send_bdf_marker","title":"<code>send_bdf_marker(marker)</code>","text":"<p>Send marker to BDF file, can be invoked after <code>create_bdf_file()</code>, otherwise it will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>str</code> <p>marker string to write.</p> required Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def send_bdf_marker(self, marker: str):\n    \"\"\"\n    Send marker to BDF file, can be invoked after `create_bdf_file()`, otherwise it will be ignored.\n\n    Args:\n        marker: marker string to write.\n    \"\"\"\n    if self._bdf_file is not None:\n        self._bdf_file.write_Annotation(marker)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.set_frequency","title":"<code>set_frequency(fs=None)</code>","text":"<p>Update device sample frequency, this method should be invoked before <code>connect_device</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>Optional[int]</code> <p>sample frequency in Hz, if <code>fs</code> is set to <code>None</code> or not in <code>get_available_frequency()</code>, it will fall back to the lowest available frequency.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Device is already connected.</p> New in <ul> <li>now you can set the sample frequency after device connection.</li> </ul> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def set_frequency(self, fs: Optional[int] = None):\n    \"\"\"Update device sample frequency, this method should be invoked before `connect_device`.\n\n    Args:\n        fs: sample frequency in Hz, if `fs` is set to `None` or not in `get_available_frequency()`,\n            it will fall back to the lowest available frequency.\n\n    Raises:\n        Exception: Device is already connected.\n\n    New in:\n        - now you can set the sample frequency after device connection.\n    \"\"\"\n    if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        warn = \"Device acquisition in progress, please `stop_acquisition()` first.\"\n        raise Exception(warn)\n    available = self.get_available_frequency(self.__dev_args[\"type\"])\n    default = available[0]\n    if fs is None:\n        fs = default\n    if fs not in available:\n        print(f\"Invalid sample frequency, fallback to {default}Hz\")\n        fs = default\n    self.__dev_args.update({\"fs\": fs})\n    self.__parser._update_fs(fs)\n    if self.dev is not None:\n        self.dev.set_fs(fs)\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.set_update_functions","title":"<code>set_update_functions(function=None)</code>","text":"<p>set the out of class function, invoked automatically tp process data when self.__with_q is False.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[array], None]</code> <p>The target function</p> <code>None</code> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def set_update_functions(\n    self, function: Callable[[numpy.array], None] = None\n) -&gt; None:\n    \"\"\"\n    set the out of class function, invoked automatically tp process data when self.__with_q is False.\n\n    Args:\n        function: The target function\n    \"\"\"\n    self.__update_func = function\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_data","title":"<code>start_acquisition_data(with_q=True)</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> <p>Parameters:</p> Name Type Description Default <code>with_q</code> <code>bool</code> <p>if True, signal data will be stored in a queue and should be acquired by calling <code>get_data()</code> in a loop in case data queue is full. if False and __update_func has been set up, data will be passed this functions directly, which is more efficient in multithread and multiprocess(with shared memory). data can also be acquired through <code>open_lsl_stream</code> and <code>save_bdf_file</code>.</p> <code>True</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or data acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_data(self, with_q: bool = True):\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n\n    Args:\n        with_q: if True, signal data will be stored in a queue and **should** be acquired by calling `get_data()` in a loop in case data queue is full.\n            if False and __update_func has been set up, data will be passed this functions directly, which is more efficient in multithread and multiprocess(with shared memory).\n            data can also be acquired through `open_lsl_stream` and `save_bdf_file`.\n\n    Raises:\n        Exception: if device not connected or data acquisition init failed.\n    \"\"\"\n    self.__check_dev_status()\n    self.__with_q = with_q\n    if self.__status == iRecorder.Dev.SIGNAL:\n        return\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.SIGNAL_START\n    while self.__status not in [iRecorder.Dev.SIGNAL, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.start_acquisition_impedance","title":"<code>start_acquisition_impedance()</code>","text":"<p>Send impedance acquisition command to device, block until data acquisition started or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or impedance acquisition init failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def start_acquisition_impedance(self) -&gt; None:\n    \"\"\"\n    Send impedance acquisition command to device, block until data acquisition started or failed.\n\n    Raises:\n        Exception: if device not connected or impedance acquisition init failed.\n    \"\"\"\n    self.__check_dev_status()\n    if self.__status == iRecorder.Dev.IMPEDANCE:\n        return\n    if self.__status == iRecorder.Dev.SIGNAL:\n        self.stop_acquisition()\n    self.__status = iRecorder.Dev.IMPEDANCE_START\n    while self.__status not in [iRecorder.Dev.IMPEDANCE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or impedance acquisition, block until data acquisition stopped or failed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or acquisition stop failed.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or impedance acquisition, block until data acquisition stopped or failed.\n\n    Raises:\n        Exception: if device not connected or acquisition stop failed.\n    \"\"\"\n    self.__check_dev_status()\n    if self.__status == iRecorder.Dev.IDLE:\n        return\n    self.__status = iRecorder.Dev.IDLE_START\n    while self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        time.sleep(0.01)\n    self.__check_dev_status()\n</code></pre>"},{"location":"iRecorder/#eConEXG.iRecorder.iRecorder.update_channels","title":"<code>update_channels(channels=None)</code>","text":"<p>Update channels to acquire, invoke this method when device is not acquiring data or impedance.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[dict]</code> <p>channel number and name mapping, e.g. <code>{0: \"FPz\", 1: \"Oz\", 2: \"CPz\"}</code>, if <code>None</code> is given, reset to all available channels with default names.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>if data/impedance acquisition in progress.</p> Source code in <code>src\\eConEXG\\iRecorder\\device.py</code> <pre><code>def update_channels(self, channels: Optional[dict] = None):\n    \"\"\"\n    Update channels to acquire, invoke this method when device is not acquiring data or impedance.\n\n    Args:\n        channels: channel number and name mapping, e.g. `{0: \"FPz\", 1: \"Oz\", 2: \"CPz\"}`,\n            if `None` is given, reset to all available channels with default names.\n\n    Raises:\n        Exception: if data/impedance acquisition in progress.\n    \"\"\"\n    if self.__status not in [iRecorder.Dev.IDLE, iRecorder.Dev.TERMINATE]:\n        warn = \"Device acquisition in progress, please stop_acquisition() first.\"\n        raise Exception(warn)\n    if channels is None:\n        from .default_config import getChannels\n\n        channels = getChannels(self.__dev_args[\"channel\"])\n    self.__dev_args.update({\"ch_info\": channels})\n    ch_idx = [i for i in channels.keys()]\n    self.__parser._update_chs(ch_idx)\n</code></pre>"},{"location":"iSense/","title":"iSense","text":""},{"location":"iSense/#eConEXG.iSense.iSense","title":"<code>iSense</code>","text":"<p>               Bases: <code>Thread</code></p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>class iSense(Thread):\n    class Dev(Enum):\n        SIGNAL = 10  # self.Dev.SIGNAL transmision mode\n        SIGNAL_START = 11\n        IMPEDANCE = 20  # self.Dev.IMPEDANCE transmision mode\n        IMPEDANCE_START = 21\n        IDLE = 30  # self.Dev.IDLE mode\n        IDLE_START = 31\n        TERMINATE = 40  # Init state\n        TERMINATE_START = 41\n\n    def __init__(self, fs: int):\n        from .data_parser import Parser\n        from .dev_socket import iSenseUSB\n\n        print(\"initing iSense\")\n        super().__init__(daemon=True)\n        if fs not in {250, 500, 1000, 2000, 4000, 8000, 16000}:\n            raise ValueError(\"Frequency is unsupported. Available frequencies: 250, 500, 1000, 2000, 4000, 8000, 16000\")\n        self.fs = fs\n        self.__socket_flag = Queue()\n        self.__save_data = Queue()\n        self.__batt = 0\n        self.__status = self.Dev.TERMINATE\n        try:\n            self.__parser = Parser(fs=self.fs)\n            self.__dev = iSenseUSB(self.fs, self.__parser.pkt_size)\n            self.__dev.connect_socket()\n            self.__dev.stop_recv()\n            self.__socket_flag.put(\"Connected\")\n            self.__status = self.Dev.IDLE_START\n            self.start()\n        except Exception as e:\n            traceback.print_exc()\n            self.__socket_flag.put(f\"Error: {e}\")\n            return\n\n    def start_acquisition_data(self) -&gt; None:\n        \"\"\"\n        Send data acquisition command to device, block until data acquisition started or failed.\n        \"\"\"\n        if self.__status == self.Dev.TERMINATE:\n            return  # TODO: add raise exception\n        if self.__status == self.Dev.SIGNAL:\n            return\n        if self.__status == self.Dev.IMPEDANCE:\n            self.stop_acquisition()\n        self.__status = self.Dev.SIGNAL_START\n        while self.__status not in [self.Dev.SIGNAL, self.Dev.TERMINATE]:\n            time.sleep(0.01)\n\n    def get_data(self, timeout: Optional[float] = 0.01) -&gt; list[Optional[list]]:\n        \"\"\"\n        Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n        Args:\n            timeout: it blocks at most `timeout` seconds and return, otherwise it returns until new data is available.\n\n        Returns:\n            A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel,\n                eeg channels can be updatd by `update_channels()`.\n\n        Data Unit:\n            - eeg: microvolts (\u00b5V)\n            - triggerbox: int, from `0` to `255`\n\n        Raises:\n            Exception: if device not connected or in data acquisition mode.\n        \"\"\"\n        # if self.__status != self.Dev.SIGNAL:\n        #     raise Exception(\"Data acquisition not started, please start first.\")\n        try:\n            data: list = self.__save_data.get(timeout=timeout)\n        except queue.Empty:\n            return []\n        while not self.__save_data.empty():\n            data.extend(self.__save_data.get())\n        return data\n\n    def stop_acquisition(self) -&gt; None:\n        \"\"\"\n        Stop data or self.Dev.IMPEDANCE acquisition, block until data acquisition stopped or failed.\n        \"\"\"\n        if self.__status in [self.Dev.IDLE, self.Dev.TERMINATE]:\n            return\n        self.__status = self.Dev.IDLE_START\n        while self.__status not in [self.Dev.IDLE, self.Dev.TERMINATE]:\n            time.sleep(0.01)\n\n    def start_acquisition_impedance(self) -&gt; None:\n        \"\"\"\n        Send self.Dev.IMPEDANCE acquisition command to device, block until data acquisition started or failed.\n        \"\"\"\n        if self.__status == self.Dev.TERMINATE:\n            return  # TODO: add raise exception\n        if self.__status == self.Dev.IMPEDANCE:\n            return None\n        if self.__status == self.Dev.SIGNAL:\n            self.stop_acquisition()\n        self.__status = self.Dev.IMPEDANCE_START\n        while self.__status not in [self.Dev.IMPEDANCE, self.Dev.TERMINATE]:\n            time.sleep(0.01)\n        if self.__status != self.Dev.IMPEDANCE:\n            return  # TODO: add raise exception\n        return None\n\n    def get_impedance(self) -&gt; Optional[list]:\n        \"\"\"\n        Acquire channel impedances, return immediatly, self.Dev.IMPEDANCE update interval is about 2000ms.\n\n        Returns:\n            A list of channel self.Dev.IMPEDANCE ranging from `0` to `math.nan` if available, oterwise None.\n\n        Data Unit:\n            - self.Dev.IMPEDANCE: ohm (\u03a9)\n        \"\"\"\n        return self.__parser.impedance\n\n    def close_dev(self) -&gt; None:\n        \"\"\"\n        Close device connection and release resources.\n        \"\"\"\n        if self.__status not in [self.Dev.TERMINATE]:\n            # ensure socket is closed correctly\n            self.__status = self.Dev.TERMINATE_START\n            self.join()\n\n    def get_battery_value(self) -&gt; int:\n        \"\"\"\n        Query battery level.\n\n        Returns:\n            battery level in percentage, range from `0` to `100`.\n        \"\"\"\n        if (self.__parser.batt_val &gt;= 0) and (self.__parser.batt_val &lt;= 100):\n            self.__batt = self.__parser.batt_val\n        return self.__batt\n\n    def get_dev_flag(self) -&gt; Optional[str]:\n        \"\"\"\n        Query device status\n\n        Returns:\n            A list of strings.\n            Possible results: Connected, Connected lost, Error, Initialization failed...\n        \"\"\"\n        try:\n            return self.__socket_flag.get_nowait()\n        except queue.Empty:\n            return\n\n    @staticmethod\n    def get_available_frequency() -&gt; list:\n        \"\"\"Get available sample frequencies of iSense.\n\n        Returns:\n            Available sample frequencies in Hz.\n        \"\"\"\n        return [250, 500, 1000, 2000, 4000, 8000, 16000]\n\n    def run(self):\n        while self.__status not in [self.Dev.TERMINATE_START]:\n            if self.__status == self.Dev.SIGNAL_START:\n                self.__recv_data(imp_mode=False)\n            elif self.__status == self.Dev.IMPEDANCE_START:\n                self.__recv_data(imp_mode=True)\n            elif self.__status in [self.Dev.IDLE_START]:\n                self.__idle_state()\n            else:\n                print(f\"Unknown status: {self.__status}\")\n                break\n        try:\n            self.__dev.close_socket()\n        except Exception:\n            pass\n        self.__status = self.Dev.TERMINATE\n        print(\"iSense disconnected\")\n\n    def __recv_data(self, imp_mode=True):\n        self.__parser.imp_flag = imp_mode\n        try:\n            if self.__parser.imp_flag:\n                self.__dev.start_impe()\n                self.__status = self.Dev.IMPEDANCE\n            else:\n                self.__dev.start_data()\n                self.__status = self.Dev.SIGNAL\n        except Exception as e:\n            self.__socket_flag.put(f\"Data/IMPEDANCE initialization failed: {e}\")\n            self.__status = self.Dev.TERMINATE_START\n\n        try:\n            while self.__status in [self.Dev.SIGNAL, self.Dev.IMPEDANCE]:\n                data = self.__dev.recv_socket()\n                if not data:\n                    raise Exception(\"Remote end closed.\")\n                ret = self.__parser.parse_data(data)\n                if ret:\n                    self.__save_data.put(ret)\n        except Exception as e:\n            traceback.print_exc()\n            self.__socket_flag.put(f\"Transmission error: {e}\")\n            self.__status = self.Dev.TERMINATE_START\n\n        try:\n            self.__dev.stop_recv()\n        except Exception as e:\n            if self.__status == self.Dev.IDLE_START:\n                traceback.print_exc()\n                self.__socket_flag.put(f\"IDLE initialization failed: {e}\")\n            self.__status = self.Dev.TERMINATE_START\n\n        self.__parser.clear_buffer()\n        self.__save_data.put(None)\n        while self.__save_data.get() is not None:\n            continue\n        print(f\"iSense data thread closed. {datetime.now()}\")\n\n    def __idle_state(self):\n        timestamp = time.time()\n        self.__status = self.Dev.IDLE\n        while self.__status in [self.Dev.IDLE]:\n            if (time.time() - timestamp) &lt; 10:\n                time.sleep(0.2)  # to reduce cpu usage\n                continue\n            try:  # heartbeat to keep socket alive and update battery level\n                self.__dev.stop_recv()\n                timestamp = time.time()\n                # print(\"Ah, ah, ah, ah\\nStayin' alive, stayin' alive\")\n            except Exception:\n                traceback.print_exc()\n                self.__socket_flag.put(\"Connection Lost!\")\n                self.__status = self.Dev.TERMINATE_START\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.close_dev","title":"<code>close_dev()</code>","text":"<p>Close device connection and release resources.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def close_dev(self) -&gt; None:\n    \"\"\"\n    Close device connection and release resources.\n    \"\"\"\n    if self.__status not in [self.Dev.TERMINATE]:\n        # ensure socket is closed correctly\n        self.__status = self.Dev.TERMINATE_START\n        self.join()\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.get_available_frequency","title":"<code>get_available_frequency()</code>  <code>staticmethod</code>","text":"<p>Get available sample frequencies of iSense.</p> <p>Returns:</p> Type Description <code>list</code> <p>Available sample frequencies in Hz.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>@staticmethod\ndef get_available_frequency() -&gt; list:\n    \"\"\"Get available sample frequencies of iSense.\n\n    Returns:\n        Available sample frequencies in Hz.\n    \"\"\"\n    return [250, 500, 1000, 2000, 4000, 8000, 16000]\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.get_battery_value","title":"<code>get_battery_value()</code>","text":"<p>Query battery level.</p> <p>Returns:</p> Type Description <code>int</code> <p>battery level in percentage, range from <code>0</code> to <code>100</code>.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def get_battery_value(self) -&gt; int:\n    \"\"\"\n    Query battery level.\n\n    Returns:\n        battery level in percentage, range from `0` to `100`.\n    \"\"\"\n    if (self.__parser.batt_val &gt;= 0) and (self.__parser.batt_val &lt;= 100):\n        self.__batt = self.__parser.batt_val\n    return self.__batt\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.get_data","title":"<code>get_data(timeout=0.01)</code>","text":"<p>Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>it blocks at most <code>timeout</code> seconds and return, otherwise it returns until new data is available.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>list[Optional[list]]</code> <p>A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel, eeg channels can be updatd by <code>update_channels()</code>.</p> Data Unit <ul> <li>eeg: microvolts (\u00b5V)</li> <li>triggerbox: int, from <code>0</code> to <code>255</code></li> </ul> <p>Raises:</p> Type Description <code>Exception</code> <p>if device not connected or in data acquisition mode.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def get_data(self, timeout: Optional[float] = 0.01) -&gt; list[Optional[list]]:\n    \"\"\"\n    Acquire amplifier data, make sure this function is called in a loop so that it can continuously read the data.\n\n    Args:\n        timeout: it blocks at most `timeout` seconds and return, otherwise it returns until new data is available.\n\n    Returns:\n        A list of frames, each frame is a list contains all wanted eeg channels and triggerbox channel,\n            eeg channels can be updatd by `update_channels()`.\n\n    Data Unit:\n        - eeg: microvolts (\u00b5V)\n        - triggerbox: int, from `0` to `255`\n\n    Raises:\n        Exception: if device not connected or in data acquisition mode.\n    \"\"\"\n    # if self.__status != self.Dev.SIGNAL:\n    #     raise Exception(\"Data acquisition not started, please start first.\")\n    try:\n        data: list = self.__save_data.get(timeout=timeout)\n    except queue.Empty:\n        return []\n    while not self.__save_data.empty():\n        data.extend(self.__save_data.get())\n    return data\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.get_dev_flag","title":"<code>get_dev_flag()</code>","text":"<p>Query device status</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A list of strings.</p> <code>Optional[str]</code> <p>Possible results: Connected, Connected lost, Error, Initialization failed...</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def get_dev_flag(self) -&gt; Optional[str]:\n    \"\"\"\n    Query device status\n\n    Returns:\n        A list of strings.\n        Possible results: Connected, Connected lost, Error, Initialization failed...\n    \"\"\"\n    try:\n        return self.__socket_flag.get_nowait()\n    except queue.Empty:\n        return\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.get_impedance","title":"<code>get_impedance()</code>","text":"<p>Acquire channel impedances, return immediatly, self.Dev.IMPEDANCE update interval is about 2000ms.</p> <p>Returns:</p> Type Description <code>Optional[list]</code> <p>A list of channel self.Dev.IMPEDANCE ranging from <code>0</code> to <code>math.nan</code> if available, oterwise None.</p> Data Unit <ul> <li>self.Dev.IMPEDANCE: ohm (\u03a9)</li> </ul> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def get_impedance(self) -&gt; Optional[list]:\n    \"\"\"\n    Acquire channel impedances, return immediatly, self.Dev.IMPEDANCE update interval is about 2000ms.\n\n    Returns:\n        A list of channel self.Dev.IMPEDANCE ranging from `0` to `math.nan` if available, oterwise None.\n\n    Data Unit:\n        - self.Dev.IMPEDANCE: ohm (\u03a9)\n    \"\"\"\n    return self.__parser.impedance\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.start_acquisition_data","title":"<code>start_acquisition_data()</code>","text":"<p>Send data acquisition command to device, block until data acquisition started or failed.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def start_acquisition_data(self) -&gt; None:\n    \"\"\"\n    Send data acquisition command to device, block until data acquisition started or failed.\n    \"\"\"\n    if self.__status == self.Dev.TERMINATE:\n        return  # TODO: add raise exception\n    if self.__status == self.Dev.SIGNAL:\n        return\n    if self.__status == self.Dev.IMPEDANCE:\n        self.stop_acquisition()\n    self.__status = self.Dev.SIGNAL_START\n    while self.__status not in [self.Dev.SIGNAL, self.Dev.TERMINATE]:\n        time.sleep(0.01)\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.start_acquisition_impedance","title":"<code>start_acquisition_impedance()</code>","text":"<p>Send self.Dev.IMPEDANCE acquisition command to device, block until data acquisition started or failed.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def start_acquisition_impedance(self) -&gt; None:\n    \"\"\"\n    Send self.Dev.IMPEDANCE acquisition command to device, block until data acquisition started or failed.\n    \"\"\"\n    if self.__status == self.Dev.TERMINATE:\n        return  # TODO: add raise exception\n    if self.__status == self.Dev.IMPEDANCE:\n        return None\n    if self.__status == self.Dev.SIGNAL:\n        self.stop_acquisition()\n    self.__status = self.Dev.IMPEDANCE_START\n    while self.__status not in [self.Dev.IMPEDANCE, self.Dev.TERMINATE]:\n        time.sleep(0.01)\n    if self.__status != self.Dev.IMPEDANCE:\n        return  # TODO: add raise exception\n    return None\n</code></pre>"},{"location":"iSense/#eConEXG.iSense.iSense.stop_acquisition","title":"<code>stop_acquisition()</code>","text":"<p>Stop data or self.Dev.IMPEDANCE acquisition, block until data acquisition stopped or failed.</p> Source code in <code>src\\eConEXG\\iSense\\device.py</code> <pre><code>def stop_acquisition(self) -&gt; None:\n    \"\"\"\n    Stop data or self.Dev.IMPEDANCE acquisition, block until data acquisition stopped or failed.\n    \"\"\"\n    if self.__status in [self.Dev.IDLE, self.Dev.TERMINATE]:\n        return\n    self.__status = self.Dev.IDLE_START\n    while self.__status not in [self.Dev.IDLE, self.Dev.TERMINATE]:\n        time.sleep(0.01)\n</code></pre>"},{"location":"lightStimulator/","title":"Light Stimulator","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class lightStimulator:\n    def __init__(self, port: str = None):\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        self.wait_time = 0.1\n        self.channels = 6\n\n        if not port:\n            for ports in comports():\n                if (\n                    ports.pid == 0x6001\n                    and ports.vid == 0x0403\n                    and ports.serial_number in [\"LIGHTSTIMA\", \"LIGHTSTIM\"]\n                ):\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Light stimulator not found\")\n        self.dev = Serial(port, baudrate=115200, timeout=2)\n        self.dev.read_all()\n\n    def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n        \"\"\"\n        Enter VEP mode, which allows you to control the frequency of each channel separately.\n\n        Args:\n            fs: List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n                If a corresponding frequency is None, 0  or not given, it will be set to off.\n\n        Raises:\n            Exception: If the frequency is invalid or hardware error.\n        \"\"\"\n        fss = fs.copy()\n        if len(fss) &lt; self.channels:\n            fss += [0] * (self.channels - len(fss))\n        for i in range(self.channels):\n            fss[i] = self._validate_fs(fss[i])\n        command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n        command = f\"AT+VEP={command}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        if b\"SSVEP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def erp_mode(self, fs: float):\n        \"\"\"\n        Enter ERP mode, which allows you to control the frequency of all channels at once.\n\n        Args:\n            fs: Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.\n\n        Raises:\n            Exception: If the frequency is invalid or hardware error.\n        \"\"\"\n        fs = self._validate_fs(fs)\n        command = f\"AT+ERP={fs:.1f}\\r\\n\".encode()\n        self.dev.write(command)\n        time.sleep(self.wait_time)\n        ret = self.dev.read_all()\n        if b\"ERP MODE OK\" not in ret:\n            raise Exception(\"Failed to set VEP mode\")\n\n    def _validate_fs(self, fs: Optional[float]):\n        if not isinstance(fs, (int, float)):\n            if fs is None:\n                fs = 0\n            else:\n                raise Exception(\"Invalid frequency\")\n        if fs &gt; 100 or fs &lt; 0:\n            raise Exception(\"Invalid frequency\")\n        return fs\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"lightStimulator/#eConEXG.lightStimulator.erp_mode","title":"<code>erp_mode(fs)</code>","text":"<p>Enter ERP mode, which allows you to control the frequency of all channels at once.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>float</code> <p>Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the frequency is invalid or hardware error.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def erp_mode(self, fs: float):\n    \"\"\"\n    Enter ERP mode, which allows you to control the frequency of all channels at once.\n\n    Args:\n        fs: Frequency in Hz, range from 0 to 100 with 0.1Hz resolution.\n\n    Raises:\n        Exception: If the frequency is invalid or hardware error.\n    \"\"\"\n    fs = self._validate_fs(fs)\n    command = f\"AT+ERP={fs:.1f}\\r\\n\".encode()\n    self.dev.write(command)\n    time.sleep(self.wait_time)\n    ret = self.dev.read_all()\n    if b\"ERP MODE OK\" not in ret:\n        raise Exception(\"Failed to set VEP mode\")\n</code></pre>"},{"location":"lightStimulator/#eConEXG.lightStimulator.vep_mode","title":"<code>vep_mode(fs=[1, 1, 1, 1, 1, 1])</code>","text":"<p>Enter VEP mode, which allows you to control the frequency of each channel separately.</p> <p>Parameters:</p> Name Type Description Default <code>fs</code> <code>list[Optional[float]]</code> <p>List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution. If a corresponding frequency is None, 0  or not given, it will be set to off.</p> <code>[1, 1, 1, 1, 1, 1]</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the frequency is invalid or hardware error.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def vep_mode(self, fs: list[Optional[float]] = [1, 1, 1, 1, 1, 1]):\n    \"\"\"\n    Enter VEP mode, which allows you to control the frequency of each channel separately.\n\n    Args:\n        fs: List of frequencies in Hz, range from 0 to 100 with 0.1Hz resolution.\n            If a corresponding frequency is None, 0  or not given, it will be set to off.\n\n    Raises:\n        Exception: If the frequency is invalid or hardware error.\n    \"\"\"\n    fss = fs.copy()\n    if len(fss) &lt; self.channels:\n        fss += [0] * (self.channels - len(fss))\n    for i in range(self.channels):\n        fss[i] = self._validate_fs(fss[i])\n    command = \",\".join([f\"{f:.1f}\" for f in fss[: self.channels]])\n    command = f\"AT+VEP={command}\\r\\n\".encode()\n    self.dev.write(command)\n    time.sleep(self.wait_time)\n    ret = self.dev.read_all()\n    if b\"SSVEP MODE OK\" not in ret:\n        raise Exception(\"Failed to set VEP mode\")\n</code></pre>"},{"location":"triggerBoxWire/","title":"Wired","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWired:\n    def __init__(self, port: str = None):\n        \"\"\"\n        Args:\n            port: The serial port of the trigger box. If not given,\n                the function will try to find the trigger box automatically.\n\n        Raises:\n            Exception: If the trigger box is not found.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            for ports in comports():\n                if ports.pid == 0x5740 and ports.vid == 0x0483:\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Trigger box not found\")\n        self.dev = Serial(port, timeout=1)\n\n    def sendMarker(self, marker: int):\n        \"\"\"\n        Send a marker to the trigger box.\n\n        Args:\n            marker: range from `1` to `255`.\n\n        Raises:\n            Exception: If the marker is invalid.\n        \"\"\"\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        self.dev.write(marker.to_bytes(length=1, byteorder=\"big\", signed=False))\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWire/#eConEXG.triggerBoxWired.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the trigger box is not found.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port: str = None):\n    \"\"\"\n    Args:\n        port: The serial port of the trigger box. If not given,\n            the function will try to find the trigger box automatically.\n\n    Raises:\n        Exception: If the trigger box is not found.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        for ports in comports():\n            if ports.pid == 0x5740 and ports.vid == 0x0483:\n                port = ports.device\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n    self.dev = Serial(port, timeout=1)\n</code></pre>"},{"location":"triggerBoxWire/#eConEXG.triggerBoxWired.sendMarker","title":"<code>sendMarker(marker)</code>","text":"<p>Send a marker to the trigger box.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>int</code> <p>range from <code>1</code> to <code>255</code>.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the marker is invalid.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def sendMarker(self, marker: int):\n    \"\"\"\n    Send a marker to the trigger box.\n\n    Args:\n        marker: range from `1` to `255`.\n\n    Raises:\n        Exception: If the marker is invalid.\n    \"\"\"\n    if not isinstance(marker, int):\n        marker = int(marker)\n    if marker &lt;= 0 or marker &gt; 255:\n        raise Exception(\"Invalid marker\")\n    self.dev.write(marker.to_bytes(length=1, byteorder=\"big\", signed=False))\n</code></pre>"},{"location":"triggerBoxWireless/","title":"Wireless","text":"Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>class triggerBoxWireless:\n    def __init__(self, port: str = None):\n        \"\"\"\n        Args:\n            port: The serial port of the trigger box. If not given,\n                the function will try to find the trigger box automatically.\n\n        Raises:\n            Exception: If the trigger box is not found.\n        \"\"\"\n        from serial import Serial\n        from serial.tools.list_ports import comports\n\n        if not port:\n            for ports in comports():\n                if ports.pid == 0x6001 and ports.vid == 0x0403:\n                    port = ports.device\n                    break\n            else:\n                raise Exception(\"Trigger box not found\")\n        self.dev = Serial(port, baudrate=115200, timeout=1)\n        self.__last_timestamp = time.perf_counter()\n        self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n        time.sleep(0.1)\n\n    def sendMarker(self, marker: int):\n        \"\"\"\n        Send a marker to the trigger box.\n\n        Args:\n            marker: range from `1` to `255`, `13` is not available and reserved for internal use.\n\n        Raises:\n            Exception: If the marker is invalid.\n        \"\"\"\n        if time.perf_counter() - self.__last_timestamp &lt; 0.04:\n            print(self.__warn)\n        if not isinstance(marker, int):\n            marker = int(marker)\n        if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n            raise Exception(\"Invalid marker\")\n        marker = marker.to_bytes(length=1, byteorder=\"big\", signed=False)\n        self.dev.write(marker + b\"\\x55\\x66\\x0d\")\n        self.__last_timestamp = time.perf_counter()\n\n    def close_dev(self):\n        self.dev.close()\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.__init__","title":"<code>__init__(port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port of the trigger box. If not given, the function will try to find the trigger box automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the trigger box is not found.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def __init__(self, port: str = None):\n    \"\"\"\n    Args:\n        port: The serial port of the trigger box. If not given,\n            the function will try to find the trigger box automatically.\n\n    Raises:\n        Exception: If the trigger box is not found.\n    \"\"\"\n    from serial import Serial\n    from serial.tools.list_ports import comports\n\n    if not port:\n        for ports in comports():\n            if ports.pid == 0x6001 and ports.vid == 0x0403:\n                port = ports.device\n                break\n        else:\n            raise Exception(\"Trigger box not found\")\n    self.dev = Serial(port, baudrate=115200, timeout=1)\n    self.__last_timestamp = time.perf_counter()\n    self.__warn = \"Marker interval too short, amplifier may fail to receive it. Suggested interval is above 50ms\"\n    time.sleep(0.1)\n</code></pre>"},{"location":"triggerBoxWireless/#eConEXG.triggerBoxWireless.sendMarker","title":"<code>sendMarker(marker)</code>","text":"<p>Send a marker to the trigger box.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>int</code> <p>range from <code>1</code> to <code>255</code>, <code>13</code> is not available and reserved for internal use.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the marker is invalid.</p> Source code in <code>src\\eConEXG\\triggerBox\\triggerbox.py</code> <pre><code>def sendMarker(self, marker: int):\n    \"\"\"\n    Send a marker to the trigger box.\n\n    Args:\n        marker: range from `1` to `255`, `13` is not available and reserved for internal use.\n\n    Raises:\n        Exception: If the marker is invalid.\n    \"\"\"\n    if time.perf_counter() - self.__last_timestamp &lt; 0.04:\n        print(self.__warn)\n    if not isinstance(marker, int):\n        marker = int(marker)\n    if marker == 13 or marker &lt;= 0 or marker &gt; 255:\n        raise Exception(\"Invalid marker\")\n    marker = marker.to_bytes(length=1, byteorder=\"big\", signed=False)\n    self.dev.write(marker + b\"\\x55\\x66\\x0d\")\n    self.__last_timestamp = time.perf_counter()\n</code></pre>"}]}